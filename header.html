<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>External Attack Surface Analysis</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="assets/report.css" />
    <script>
      const screenshotMap =
      %%SCREENSHOT_MAP%%
      ;
    </script>
  </head>
  <body>
    <header class="header">
      <div class="header__content">
        <div class="header__titles">
          <p class="header__eyebrow">Reconnaissance Intelligence Report</p>
          <h1>External Attack Surface Analysis</h1>
          <p class="header__subtitle">Consolidated intelligence across discovered assets, live exposure points, and defensive posture.</p>
        </div>
        <div class="header__actions">
          <button id="exportCsvButton" class="btn btn--primary">Export CSV</button>
        </div>
      </div>
    </header>

    <main class="container">
      <section class="scoreboard" id="scoreboard"></section>

      <section class="charts-grid">
        <div class="chart-container"><h3>Asset Overview</h3><canvas id="priorityChart"></canvas></div>
        <div class="chart-container"><h3>Domains by Status</h3><canvas id="domainCountChart"></canvas></div>
        <div class="chart-container"><h3>Internal vs External Footprint</h3><canvas id="colleagueEndpointChart"></canvas></div>
        <div class="chart-container"><h3>Login Surface</h3><canvas id="loginBarChart"></canvas></div>
        <div class="chart-container"><h3>HTTP Status Codes</h3><canvas id="statusCodeChart"></canvas></div>
        <div class="chart-container"><h3>Top Ports</h3><canvas id="portChart"></canvas></div>
        <div class="chart-container"><h3>Service Exposure</h3><canvas id="serviceChart"></canvas></div>
        <div class="chart-container"><h3>Technology Stack</h3><canvas id="techChart"></canvas></div>
        <div class="chart-container"><h3>TLS Adoption</h3><canvas id="tlsUsageChart"></canvas></div>
        <div class="chart-container"><h3>Certificate Expiry</h3><canvas id="certExpiryChart"></canvas></div>
        <div class="chart-container"><h3>Security Headers</h3><canvas id="headersChart"></canvas></div>
        <div class="chart-container"><h3>Email Security</h3><canvas id="emailSecChart"></canvas></div>
        <div class="chart-container"><h3>CDN Distribution</h3><canvas id="cdnStackedChart"></canvas></div>
        <div class="chart-container"><h3>Nameserver Footprint</h3><canvas id="nsChart"></canvas></div>
      </section>

      <section class="table-top-controls">
        <input type="text" id="searchBox" placeholder="Filter results (domain, status code, technology…)" />
        <div class="hint">Hover the Attack Surface Score to review the contextual risk factors.</div>
        <div class="table-controls">
          <label for="rowsPerPageSelect">Rows per page</label>
          <select id="rowsPerPageSelect">
            <option value="20">20</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="all">ALL</option>
          </select>
        </div>
      </section>

      <div class="table-container">
        <table id="report-table">
          <thead>
            <tr>
              <th id="riskScoreHeader">Attack Surface Score<span id="riskSortToggle">▼</span></th>
              <th>Domain</th>
              <th>Purpose</th>
              <th>Resolvers</th>
              <th>A Records</th>
              <th>NS Records</th>
              <th>MX Records</th>
              <th>PTR Records</th>
              <th>DNS Status</th>
              <th>CDN Name</th>
              <th>CDN Type</th>
              <th>Port</th>
              <th>URL</th>
              <th>Screenshot</th>
              <th>Redirect Location</th>
              <th>Homepage Title</th>
              <th>Web Server</th>
              <th>Login Found</th>
              <th>API Endpoint</th>
              <th>Technology Stack</th>
              <th>Status Code</th>
              <th>Content Length</th>
              <th>CDN</th>
              <th>SPF Record</th>
              <th>DKIM Record</th>
              <th>DMARC Record</th>
              <th>DNSSEC Record</th>
              <th>SSL/TLS Version</th>
              <th>Cert Expiry Date</th>
              <th>SSL/TLS Issuer</th>
              <th>Strict-Transport-Security</th>
              <th>X-Frame-Options</th>
              <th>Content-Security-Policy</th>
              <th>X-XSS-Protection</th>
              <th>Referrer Policy</th>
              <th>Permissions Policy</th>
              <th>Open Ports / Services</th>
              <th>Crawled Links</th>
            </tr>
            <tr id="filter-row">
              <th><select id="priority-filter"><option value="">All</option></select></th>
              <th><select id="domain-filter"><option value="">All</option></select></th>
              <th><select id="purpose-filter"><option value="">All</option></select></th>
              <th><select id="resolvers-filter"><option value="">All</option></select></th>
              <th><select id="arecords-filter"><option value="">All</option></select></th>
              <th><select id="ns-filter"><option value="">All</option></select></th>
              <th><select id="mx-filter"><option value="">All</option></select></th>
              <th><select id="ptr-filter"><option value="">All</option></select></th>
              <th><select id="dnsstatus-filter"><option value="">All</option></select></th>
              <th><select id="cdnname-filter"><option value="">All</option></select></th>
              <th><select id="cdntype-filter"><option value="">All</option></select></th>
              <th><select id="port-filter"><option value="">All</option></select></th>
              <th><select id="url-filter"><option value="">All</option></select></th>
              <th>
                <select id="screenshot-filter">
                  <option value="">All</option>
                  <option value="has screenshot">Has screenshot</option>
                  <option value="no screenshot">No screenshot</option>
                </select>
              </th>
              <th><select id="redirect-filter"><option value="">All</option></select></th>
              <th><select id="title-filter"><option value="">All</option></select></th>
              <th><select id="webserver-filter"><option value="">All</option></select></th>
              <th><select id="login-filter"><option value="">All</option></select></th>
              <th><select id="api-endpoint-filter"><option value="">All</option></select></th>
              <th><select id="tech-filter"><option value="">All</option></select></th>
              <th><select id="statuscode-filter"><option value="">All</option></select></th>
              <th><select id="contentlength-filter"><option value="">All</option></select></th>
              <th><select id="cdn-filter"><option value="">All</option></select></th>
              <th><select id="spf-filter"><option value="">All</option></select></th>
              <th><select id="dkim-filter"><option value="">All</option></select></th>
              <th><select id="dmarc-filter"><option value="">All</option></select></th>
              <th><select id="dnssec-filter"><option value="">All</option></select></th>
              <th><select id="sslversion-filter"><option value="">All</option></select></th>
              <th><select id="certexpiry-filter"><option value="">All</option></select></th>
              <th><select id="sslissuer-filter"><option value="">All</option></select></th>
              <th><select id="sts-filter"><option value="">All</option></select></th>
              <th><select id="xfo-filter"><option value="">All</option></select></th>
              <th><select id="csp-filter"><option value="">All</option></select></th>
              <th><select id="xss-filter"><option value="">All</option></select></th>
              <th><select id="rp-filter"><option value="">All</option></select></th>
              <th><select id="pp-filter"><option value="">All</option></select></th>
              <th><select id="ports-services-filter"><option value="">All</option></select></th>
              <th><select id="crawledlinks-filter"><option value="">All</option></select></th>
            </tr>
          </thead>
          <tbody id="report-table-body"></tbody>
        </table>
      </div>
      <div id="paginationControls"></div>

      <div id="screenshotModal">
        <div id="screenshotModalContent">
          <button id="closeModalBtn" onclick="closeModal()" aria-label="Close screenshot viewer">&times;</button>
          <img id="screenshotModalImg" src="" alt="Full Screenshot" />
        </div>
      </div>

      <div id="linksModal">
        <div>
          <button onclick="closeLinksModal()" aria-label="Close links viewer">&times;</button>
          <div id="linksModalBody"></div>
        </div>
      </div>
    </main>
    <script>
      // Plugin for displaying labels on bars in charts
      const barLabelPlugin = {
        id: 'barLabelPlugin',
        afterDatasetsDraw(chart, args, options) {
          const { ctx } = chart;
          const metaSets = chart.getSortedVisibleDatasetMetas().filter(m => m.type === 'bar');
          const tokens = getDesignTokens();
          const labelColor = getChartTextColor(tokens);
          metaSets.forEach(meta => {
            meta.data.forEach((element, index) => {
              const parsed = meta._parsed && meta._parsed[index];
              let value = typeof parsed === "object" && parsed !== null
                ? parsed[meta.vScale.axis]
                : parsed;
              if (value === undefined || value === null) {
                const dataset = meta._dataset && Array.isArray(meta._dataset.data)
                  ? meta._dataset.data[index]
                  : undefined;
                if (typeof dataset === "object" && dataset !== null) {
                  value = dataset[meta.vScale?.axis] ?? dataset.y ?? dataset;
                } else {
                  value = dataset;
                }
              }
              if (value === 0) return;
              const { x, y } = element.tooltipPosition();
              ctx.save();
              ctx.fillStyle = labelColor;
              ctx.font = options.font || '9px sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              ctx.fillText(value, x, y - 2);
              ctx.restore();
            });
          });
        }
      };
      Chart.register(barLabelPlugin);

      function getDesignTokens() {
        const styles = getComputedStyle(document.body);
        const readToken = (token, fallback) => {
          const value = styles.getPropertyValue(token);
          return value ? value.trim() || fallback : fallback;
        };
        const fontToken = readToken("--font-family-base", "Inter, system-ui, sans-serif");
        return {
          text: readToken("--color-text", "#0f172a"),
          muted: readToken("--color-text-muted", "#475569"),
          border: readToken("--color-border", "rgba(15, 23, 42, 0.18)"),
          grid: readToken("--color-gridline", "rgba(148, 163, 184, 0.22)"),
          fontFamily: fontToken.replace(/['"]/g, "").trim() || "Inter, system-ui, sans-serif"
        };
      }

      function getChartTextColor(tokens) {
        return tokens.text;
      }

      function applyChartDefaults() {
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        Chart.defaults.font.family = tokens.fontFamily;
        Chart.defaults.font.size = 12;
        Chart.defaults.font.weight = "500";
        Chart.defaults.color = chartText;
        Chart.defaults.borderColor = tokens.grid;
        if (Chart.defaults.plugins?.legend?.labels) {
          Chart.defaults.plugins.legend.labels.color = chartText;
          Chart.defaults.plugins.legend.labels.font = Chart.defaults.plugins.legend.labels.font || {};
          Chart.defaults.plugins.legend.labels.font.family = tokens.fontFamily;
          Chart.defaults.plugins.legend.labels.font.weight = "500";
        }
        if (Chart.defaults.plugins?.tooltip) {
          Chart.defaults.plugins.tooltip.titleColor = chartText;
          Chart.defaults.plugins.tooltip.bodyColor = chartText;
          Chart.defaults.plugins.tooltip.titleFont = Chart.defaults.plugins.tooltip.titleFont || {};
          Chart.defaults.plugins.tooltip.bodyFont = Chart.defaults.plugins.tooltip.bodyFont || {};
          Chart.defaults.plugins.tooltip.titleFont.family = tokens.fontFamily;
          Chart.defaults.plugins.tooltip.titleFont.weight = "600";
          Chart.defaults.plugins.tooltip.bodyFont.family = tokens.fontFamily;
          Chart.defaults.plugins.tooltip.bodyFont.weight = "500";
        }
        return tokens;
      }

      applyChartDefaults();

      // Global variables for charts and table data.
      let priorityChart, domainCountChart, statusCodeChart, loginChart, portChart, techChart, certExpiryChart, tlsUsageChart, headersChart, emailSecChart, cdnChart, serviceChart, colleagueChart, cdnTypeChart, cdnStackedChart, nsChart;
      let allTableRows = [];
      let currentPage = 1;
      let rowsPerPage = 20;
      let riskScores = {};
      let minRiskScore = Infinity;
      let maxRiskScore = -Infinity;
      let riskSortOrder = "desc";

      // CSV Export Functions
      function downloadCSV(csv, filename) {
        const csvFile = new Blob([csv], { type: "text/csv" });
        const downloadLink = document.createElement("a");
        downloadLink.download = filename;
        downloadLink.href = window.URL.createObjectURL(csvFile);
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      }
      function exportAllTableRowsToCSV(filename) {
        const csv = [];
        const headerRow = document.querySelectorAll("#report-table thead tr")[0];
        const headers = [];
        headerRow.querySelectorAll("th").forEach(th => {
          headers.push('"' + th.innerText.trim().replace(/"/g, '""') + '"');
        });
        csv.push(headers.join(","));
        allTableRows.forEach(row => {
          const cols = row.querySelectorAll("td");
          const rowData = [];
          cols.forEach(td => {
            const text = getCellContentText(td);
            rowData.push('"' + text.replace(/"/g, '""') + '"');
          });
          csv.push(rowData.join(","));
        });
        downloadCSV(csv.join("\n"), filename);
      }
      document.getElementById("exportCsvButton").addEventListener("click", function() {
        exportAllTableRowsToCSV("report.csv");
      });

      function getCellContentText(cell) {
        if (!cell) return "";
        const wrapper = cell.querySelector(".cell-content");
        const source = wrapper || cell;
        return (source.innerText || "").trim();
      }

      function prepareRowCells(row) {
        const cells = Array.from(row.cells);
        cells.forEach((cell, index) => {
          if (index === 0) return;
          if (cell.dataset.clampPrepared === "true") return;
          if (cell.querySelector("img")) {
            cell.dataset.clampPrepared = "true";
            return;
          }
          const wrapper = document.createElement("div");
          wrapper.className = "cell-content";
          while (cell.firstChild) {
            wrapper.appendChild(cell.firstChild);
          }
          cell.appendChild(wrapper);
          const button = document.createElement("button");
          button.type = "button";
          button.className = "cell-expander";
          button.textContent = "View more";
          button.setAttribute("aria-expanded", "false");
          button.addEventListener("click", () => {
            const expanded = cell.classList.toggle("is-expanded");
            button.textContent = expanded ? "View less" : "View more";
            button.setAttribute("aria-expanded", String(expanded));
            updateSingleCellClamp(cell);
          });
          cell.appendChild(button);
          cell.dataset.clampPrepared = "true";
          updateSingleCellClamp(cell);
        });
      }

      function updateSingleCellClamp(cell) {
        const wrapper = cell.querySelector(".cell-content");
        const button = cell.querySelector(".cell-expander");
        if (!wrapper || !button) return;
        if (cell.classList.contains("is-expanded")) {
          cell.classList.add("is-clamped");
          button.style.display = "inline-flex";
          button.textContent = "View less";
          button.setAttribute("aria-expanded", "true");
          return;
        }
        const needsClamp = wrapper.scrollHeight > wrapper.clientHeight + 1;
        if (needsClamp) {
          cell.classList.add("is-clamped");
          button.style.display = "inline-flex";
          button.textContent = "View more";
          button.setAttribute("aria-expanded", "false");
        } else {
          cell.classList.remove("is-clamped", "is-expanded");
          button.style.display = "none";
          button.textContent = "View more";
          button.setAttribute("aria-expanded", "false");
        }
      }

      function updateClampStates(rows) {
        rows.forEach(row => {
          const cells = Array.from(row.cells);
          cells.forEach((cell, index) => {
            if (index === 0) return;
            if (cell.dataset.clampPrepared === "true") {
              updateSingleCellClamp(cell);
            }
          });
        });
      }

      // Theme support removed; charts render with default styling.

      // Utility function
      function formatCell(arr) {
        return (arr && arr.length) ? arr.join("<br>") : "N/A";
      }

      // Compute risk score
      function computePriority({
        purpose, url, loginFound, statusCode, sslVersion, certExpiry,
        sts, xfo, csp, xss, rp, pp, openPortsCount, dbPortsCount, managementPortsCount, techCount, linkCount
      }) {

        let score = 0;
        const reasons = [];
        if (purpose && purpose.toLowerCase().includes("employee")) {
          score += 1;
          reasons.push("+1 (Potential employee-intended domain found)");
        }
        if (url && url !== "N/A") {
          score += 1;
          reasons.push("+1 (Domain has live application)");
        }
        if (loginFound === "Yes") {
          score += 1;
          reasons.push("+1 (Login interface found on application)");
        }
        if (statusCode === 200) {
          score += 1;
          reasons.push("+1 (Application has 200 status code)");
        }
        if (sslVersion) {
          const cleanVersion = sslVersion.replace(/\s+/g, '');
          if (/^TLSv(1\.2|1\.3)$/i.test(cleanVersion)) {
            reasons.push("+0 (Version of TLS is latest)");
          } else if (/^TLSv(1\.0|1\.1)$/i.test(cleanVersion)) {
            score += 2;
            reasons.push("+1 (TLSv1.0 or TLSv1.1)");
          } else if (/^SSLv(1\.0|2\.0|3\.0)$/i.test(cleanVersion)) {
            score += 5;
            reasons.push("+5 (SSLv1/2/3)");
          }
        } else {
          score += 1;
          reasons.push("+1 (no sslVersion reported)");
        }
        if (certExpiry && certExpiry !== "N/A") {
          const expiryDate = new Date(certExpiry);
          const now = new Date();
          const diffDays = (expiryDate - now) / (1000 * 60 * 60 * 24);
          if (!isNaN(diffDays)) {
            if (diffDays < 0) {
              score += 20;
              reasons.push("+20 (certificate expired)");
            } else if (diffDays <= 7) {
              score += 10;
              reasons.push("+10 (cert expires in ≤7 days)");
            } else if (diffDays <= 14) {
              score += 5;
              reasons.push("+5 (cert expires in ≤14 days)");
            } else if (diffDays <= 30) {
              score += 2;
              reasons.push("+2 (cert expires in ≤30 days)");
            }
          }
        }
        function missingHeader(val) {
          return !val || val.trim() === "" || val.trim().toLowerCase() === "false";
        }
        if (missingHeader(sts)) { score += 1; reasons.push("+1 (Missing HSTS)"); }
        if (missingHeader(xfo)) { score += 1; reasons.push("+1 (Missing X-Frame-Options)"); }
        if (missingHeader(csp)) { score += 1; reasons.push("+1 (missing CSP)"); }
        if (missingHeader(xss)) { score += 1; reasons.push("+1 (Missing X-XSS-Protection)"); }
        if (missingHeader(rp)) { score += 1; reasons.push("+1 (Missing Referrer-Policy)"); }
        if (missingHeader(pp)) { score += 1; reasons.push("+1 (Missing Permissions-Policy)"); }
        if (openPortsCount && Number.isFinite(openPortsCount)) {
          score += openPortsCount;
          reasons.push(`+${openPortsCount} (Each Open ports)`);
        }
        if (dbPortsCount && Number.isFinite(dbPortsCount)) {
          score += dbPortsCount;
          reasons.push(`+${dbPortsCount} (Database ports)`);
        }
        if (managementPortsCount && Number.isFinite(managementPortsCount)) {
          score += managementPortsCount;
          reasons.push(`+${managementPortsCount} (Management ports)`);
        }
        if (techCount && Number.isFinite(techCount)) {
          score += techCount;
          reasons.push(`+${techCount} (Tech stack count)`);
        }
        if (linkCount && Number.isFinite(linkCount) && linkCount > 0) {
          score += linkCount;
          reasons.push(`+${linkCount} (Crawled links discovered)`);
        }
        return { score, debug: reasons };
      }

      function getDynamicColor(score, minScore, maxScore) {
        if (maxScore === minScore) return "rgb(46, 204, 113)";
        const fraction = (score - minScore) / (maxScore - minScore);
        const start = { r: 46, g: 204, b: 113 };
        const end   = { r: 231, g: 76, b: 60 };
        const r = Math.round(start.r + fraction * (end.r - start.r));
        const g = Math.round(start.g + fraction * (end.g - start.g));
        const b = Math.round(start.b + fraction * (end.b - start.b));
        return `rgb(${r}, ${g}, ${b})`;
      }

      function buildScoreboard({ totalSubdomains, liveSubs, totalHttpx, loginFoundCount }) {
        const sb = document.getElementById("scoreboard");
        const format = (value) => Number(value || 0).toLocaleString();
        sb.innerHTML = `
          <article class="score-card">
            <p class="score-card__label">Total Unique Assets</p>
            <h2>${format(totalSubdomains)}</h2>
          </article>
          <article class="score-card">
            <p class="score-card__label">Live Assets</p>
            <h2>${format(liveSubs)}</h2>
          </article>
          <article class="score-card">
            <p class="score-card__label">Application Endpoints</p>
            <h2>${format(totalHttpx)}</h2>
          </article>
          <article class="score-card">
            <p class="score-card__label">Login Interfaces</p>
            <h2>${format(loginFoundCount)}</h2>
          </article>
        `;
      }

      // The following functions build various charts...
      function buildCharts({ statusCount, priorityCount, portCount, techCount, totalSubdomains, liveSubs, endpointsCount }) {
        const scCanvas = document.getElementById("statusCodeChart");
        const prCanvas = document.getElementById("priorityChart");
        const portCanvas = document.getElementById("portChart");
        const techCanvas = document.getElementById("techChart");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        const createTicks = () => ({
          color: chartText,
          font: { family: tokens.fontFamily, weight: "500" }
        });
        const createGrid = (display = true) => ({
          color: tokens.grid,
          drawBorder: false,
          borderDash: [4, 4],
          display
        });
        if (prCanvas) {
          const funnelLabels = ["Total Assets", "Live Assets", "Applications"];
          const funnelValues = [totalSubdomains, liveSubs, endpointsCount];
          if (priorityChart) priorityChart.destroy();
          priorityChart = new Chart(prCanvas, {
            type: "bar",
            data: {
              labels: funnelLabels,
              datasets: [{
                label: "Assets Overview",
                data: funnelValues,
                backgroundColor: ["#3b82f6", "#8b5cf6", "#14b8a6"],
                hoverBackgroundColor: ["#2563eb", "#7c3aed", "#0d9488"],
                borderRadius: 12,
                maxBarThickness: 48
              }]
            },
            options: {
              responsive: true,
              indexAxis: "x",
              plugins: { legend: { display: false } },
              scales: {
                x: {
                  ticks: createTicks(),
                  grid: createGrid(false)
                },
                y: {
                  beginAtZero: true,
                  ticks: createTicks(),
                  grid: createGrid()
                }
              }
            }
          });
        }
        if (scCanvas) {
          const sortedKeys = Object.keys(statusCount).sort((a, b) => +a - +b);
          statusCodeChart = new Chart(scCanvas, {
            type: "bar",
            data: {
              labels: sortedKeys,
              datasets: [{
                label: "HTTP Status Codes",
                data: sortedKeys.map(l => statusCount[l]),
                backgroundColor: ["#60a5fa","#34d399","#a855f7","#facc15","#fb7185","#38bdf8","#cbd5f5"],
                borderRadius: 10,
                maxBarThickness: 36
              }]
            },
            options: {
              responsive: true,
              plugins: { legend: { display: false } },
              scales: {
                x: {
                  ticks: createTicks(),
                  grid: createGrid(false)
                },
                y: {
                  beginAtZero: true,
                  ticks: createTicks(),
                  grid: createGrid()
                }
              }
            }
          });
        }
        if (portCanvas) {
          const sortedPorts = Object.keys(portCount).sort((a, b) => portCount[b] - portCount[a]);
          const top10Ports = sortedPorts.slice(0, 10);
          portChart = new Chart(portCanvas, {
            type: "bar",
            data: {
              labels: top10Ports,
              datasets: [{
                label: "Open Ports",
                data: top10Ports.map(p => portCount[p]),
                backgroundColor: "#f97316",
                hoverBackgroundColor: "#ea580c",
                borderRadius: 10,
                maxBarThickness: 36
              }]
            },
            options: {
              responsive: true,
              plugins: { legend: { display: false } },
              scales: {
                x: {
                  ticks: createTicks(),
                  grid: createGrid(false)
                },
                y: {
                  beginAtZero: true,
                  ticks: createTicks(),
                  grid: createGrid()
                }
              }
            }
          });
        }
        if (techCanvas) {
          const sortedTech = Object.keys(techCount).sort((a, b) => techCount[b] - techCount[a]);
          const top10 = sortedTech.slice(0, 10);
          techChart = new Chart(techCanvas, {
            type: "bar",
            data: {
              labels: top10,
              datasets: [{
                label: "Tech Usage (Top 10)",
                data: top10.map(t => techCount[t]),
                backgroundColor: "#6366f1",
                hoverBackgroundColor: "#4f46e5",
                borderRadius: 10,
                maxBarThickness: 36
              }]
            },
            options: {
              responsive: true,
              indexAxis: "x",
              plugins: { legend: { display: false } },
              scales: {
                x: {
                  ticks: {
                    ...createTicks(),
                    maxRotation: 40,
                    minRotation: 0
                  },
                  grid: createGrid(false)
                },
                y: {
                  beginAtZero: true,
                  ticks: createTicks(),
                  grid: createGrid()
                }
              }
            }
          });
        }
      }

      function buildCDNStackedChart(httpxData) {
        const cdnMap = {};
        httpxData.forEach(record => {
          let cdnName = record.cdn_name && record.cdn_name.trim();
          let cdnType = record.cdn_type && record.cdn_type.trim();
          if (!cdnName || cdnName === "N/A") return;
          if (!cdnType || cdnType === "N/A") cdnType = "Unknown";
          if (!cdnMap[cdnName]) cdnMap[cdnName] = {};
          cdnMap[cdnName][cdnType] = (cdnMap[cdnName][cdnType] || 0) + 1;
        });
        const cdnNames = Object.keys(cdnMap);
        const cdnTypesSet = new Set();
        cdnNames.forEach(name => { Object.keys(cdnMap[name]).forEach(type => cdnTypesSet.add(type)); });
        const cdnTypes = Array.from(cdnTypesSet);
        const palette = ["#3498db","#1abc9c","#9b59b6","#f1c40f","#e74c3c","#34495e","#95a5a6","#e67e22","#2ecc71","#8e44ad","#7f8c8d"];
        const datasets = cdnTypes.map((type, idx) => ({
          label: type,
          data: cdnNames.map(name => cdnMap[name][type] || 0),
          backgroundColor: palette[idx % palette.length],
          borderRadius: 8,
          maxBarThickness: 36
        }));
        const ctx = document.getElementById("cdnStackedChart").getContext("2d");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        const ticks = () => ({
          color: chartText,
          font: { family: tokens.fontFamily, weight: "500" }
        });
        cdnStackedChart = new Chart(ctx, {
          type: "bar",
          data: { labels: cdnNames, datasets: datasets },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: "bottom",
                labels: {
                  usePointStyle: true,
                  boxWidth: 10,
                  color: chartText,
                  font: { family: tokens.fontFamily, weight: "500" }
                }
              },
              tooltip: { mode: "index", intersect: false }
            },
            scales: {
              x: {
                stacked: true,
                ticks: ticks(),
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                ticks: ticks(),
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildDomainCountChart(httpxData) {
        const domainCount = {};
        httpxData.forEach(h => {
          if (h.url && h.url !== "N/A") {
            const domain = (h.input || "").split(":")[0];
            domainCount[domain] = (domainCount[domain] || 0) + 1;
          }
        });
        const sortedDomains = Object.keys(domainCount).sort((a, b) => domainCount[b] - domainCount[a]);
        const top10 = sortedDomains.slice(0, 10);
        const data = top10.map(d => domainCount[d]);
        const ctx = document.getElementById("domainCountChart").getContext("2d");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        domainCountChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: top10,
            datasets: [{
              label: "Top 10 Domains (Active URLs)",
              data,
              backgroundColor: "#38bdf8",
              hoverBackgroundColor: "#0ea5e9",
              borderRadius: 10,
              maxBarThickness: 36
            }]
          },
          options: {
            responsive: true,
            indexAxis: "x",
            plugins: { legend: { display: false } },
            scales: {
              x: {
                beginAtZero: true,
                ticks: {
                  color: chartText,
                  font: { family: tokens.fontFamily, weight: "500" },
                  stepSize: 1,
                  maxRotation: 40,
                  minRotation: 0
                },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4], display: false }
              },
              y: {
                beginAtZero: true,
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildLoginBarChart(endpointsCount, loginFoundCount) {
        const canvas = document.getElementById("loginBarChart");
        if (!canvas) return;
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        loginChart = new Chart(canvas, {
          type: "bar",
          data: {
            labels: ["Found", "Not Found"],
            datasets: [{
              data: [loginFoundCount, endpointsCount - loginFoundCount],
              backgroundColor: ["#ef4444", "#22c55e"],
              hoverBackgroundColor: ["#dc2626", "#16a34a"],
              borderRadius: 10,
              maxBarThickness: 42
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              x: {
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4], display: false }
              },
              y: {
                beginAtZero: true,
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildCertExpiryChart(secData) {
        let now = new Date(), expired = 0, exp7 = 0, exp14 = 0, exp30 = 0;
        secData.forEach(item => {
          const expiryStr = item["Cert Expiry Date"];
          if (expiryStr && expiryStr !== "N/A") {
            let expiryDate = new Date(expiryStr);
            if (!isNaN(expiryDate)) {
              let diffDays = (expiryDate - now) / (1000 * 60 * 60 * 24);
              if (diffDays < 0) expired++;
              else if (diffDays <= 7) exp7++;
              else if (diffDays <= 14) exp14++;
              else if (diffDays <= 30) exp30++;
            }
          }
        });
        const ctx = document.getElementById("certExpiryChart").getContext("2d");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        certExpiryChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["Expired", "Next 7 Days", "Next 14 Days", "Next 30 Days"],
            datasets: [{
              label: "Certs Expiring",
              data: [expired, exp7, exp14, exp30],
              backgroundColor: ["#f97316", "#fb7185", "#eab308", "#38bdf8"],
              hoverBackgroundColor: ["#ea580c", "#f43f5e", "#ca8a04", "#0ea5e9"],
              borderRadius: 10,
              maxBarThickness: 36
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              x: {
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4], display: false }
              },
              y: {
                beginAtZero: true,
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildTLSUsageChart(secData) {
        const tlsCounts = {};
        secData.forEach(item => {
          let ver = item["SSL/TLS Version"];
          ver = ver ? ver.trim() : "Unknown";
          tlsCounts[ver] = (tlsCounts[ver] || 0) + 1;
        });
        const labels = Object.keys(tlsCounts);
        const data = labels.map(l => tlsCounts[l]);
        const ctx = document.getElementById("tlsUsageChart").getContext("2d");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        tlsUsageChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels,
            datasets: [{
              label: "TLS Version Usage",
              data,
              backgroundColor: "#22c55e",
              hoverBackgroundColor: "#16a34a",
              borderRadius: 10,
              maxBarThickness: 36
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              x: {
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4], display: false }
              },
              y: {
                beginAtZero: true,
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildHeadersChart(httpxData, secMapUrlParam) {
        let hstsPresent = 0, hstsMissing = 0, xfoPresent = 0, xfoMissing = 0,
            cspPresent = 0, cspMissing = 0, xssPresent = 0, xssMissing = 0,
            rpPresent = 0, rpMissing = 0, ppPresent = 0, ppMissing = 0;
        httpxData.forEach(record => {
          const sec = secMapUrlParam[record.url] || {};
          const hsts = (sec["Strict-Transport-Security"] || "").trim();
          hsts && hsts.toLowerCase() !== "n/a" && hsts.toLowerCase() !== "false" ? hstsPresent++ : hstsMissing++;
          const xfo = (sec["X-Frame-Options"] || "").trim();
          xfo && xfo.toLowerCase() !== "n/a" && xfo.toLowerCase() !== "false" ? xfoPresent++ : xfoMissing++;
          const csp = (sec["Content-Security-Policy"] || "").trim();
          csp && csp.toLowerCase() !== "n/a" && csp.toLowerCase() !== "false" ? cspPresent++ : cspMissing++;
          const xss = (sec["X-XSS-Protection"] || "").trim();
          xss && xss.toLowerCase() !== "n/a" && xss.toLowerCase() !== "false" ? xssPresent++ : xssMissing++;
          const rp = (sec["Referrer-Policy"] || "").trim();
          rp && rp.toLowerCase() !== "n/a" && rp.toLowerCase() !== "false" ? rpPresent++ : rpMissing++;
          const pp = (sec["Permissions-Policy"] || "").trim();
          pp && pp.toLowerCase() !== "n/a" && pp.toLowerCase() !== "false" ? ppPresent++ : ppMissing++;
        });
        const ctx = document.getElementById("headersChart").getContext("2d");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        const ticks = () => ({ color: chartText, font: { family: tokens.fontFamily, weight: "500" } });
        headersChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["HSTS", "X-Frame-Options", "CSP", "X-XSS-Protection", "Referrer-Policy", "Permissions-Policy"],
            datasets: [
              {
                label: "Present",
                data: [hstsPresent, xfoPresent, cspPresent, xssPresent, rpPresent, ppPresent],
                backgroundColor: "#22c55e",
                borderRadius: 8,
                maxBarThickness: 30
              },
              {
                label: "Missing",
                data: [hstsMissing, xfoMissing, cspMissing, xssMissing, rpMissing, ppMissing],
                backgroundColor: "#ef4444",
                borderRadius: 8,
                maxBarThickness: 30
              }
            ]
          },
          options: {
            responsive: true,
            indexAxis: "x",
            plugins: {
              legend: {
                position: "bottom",
                labels: {
                  usePointStyle: true,
                  boxWidth: 10,
                  color: chartText,
                  font: { family: tokens.fontFamily, weight: "500" }
                }
              },
              tooltip: { mode: "index", intersect: false }
            },
            scales: {
              x: {
                stacked: true,
                ticks: ticks(),
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4], display: false }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                ticks: ticks(),
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildEmailSecChart(secData) {
        let spfSet = 0, spfMissing = 0, dkimSet = 0, dkimMissing = 0, dmarcSet = 0, dmarcMissing = 0;
        secData.forEach(item => {
          const spf = item["SPF Record"] || "";
          const dkim = item["DKIM Record"] || "";
          const dmarc = item["DMARC Record"] || "";
          spf.toLowerCase().includes("spf1") ? spfSet++ : spfMissing++;
          dkim.toLowerCase().includes("dkim1") ? dkimSet++ : dkimMissing++;
          dmarc.toLowerCase().includes("dmarc1") ? dmarcSet++ : dmarcMissing++;
        });
        const ctx = document.getElementById("emailSecChart").getContext("2d");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        const ticks = () => ({ color: chartText, font: { family: tokens.fontFamily, weight: "500" } });
        emailSecChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["SPF", "DKIM", "DMARC"],
            datasets: [
              {
                label: "Present",
                data: [spfSet, dkimSet, dmarcSet],
                backgroundColor: "#22c55e",
                borderRadius: 8,
                maxBarThickness: 30
              },
              {
                label: "Missing",
                data: [spfMissing, dkimMissing, dmarcMissing],
                backgroundColor: "#ef4444",
                borderRadius: 8,
                maxBarThickness: 30
              }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: "bottom",
                labels: {
                  usePointStyle: true,
                  boxWidth: 10,
                  color: chartText,
                  font: { family: tokens.fontFamily, weight: "500" }
                }
              },
              tooltip: { mode: "index", intersect: false }
            },
            scales: {
              x: {
                stacked: true,
                ticks: ticks(),
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4], display: false }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                ticks: ticks(),
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildServiceChart(naabuData) {
        const naabuMap = {};
        const serviceCount = {};
        naabuData.forEach(n => {
          const domain = n.host;
          const port = n.port;
          let service = "Unknown";
          const portServiceDB = {"7":"Echo","9":"Discard","13":"Daytime","21":"FTP","22":"SSH","23":"Telnet","25":"Simple Mail Transfer","26":"Unassigned","37":"Time","53":"Domain Name Server","66":"Oracle SQL*NET","79":"Finger","80":"HTTP","81":"Unassigned","88":"Kerberos","92":"Network Printing Protocol","99":"Metagram Relay","106":"3COM-TSMUX","110":"Post Office Protocol - Version 3","111":"SUN Remote Procedure Call","113":"Authentication Service","119":"Network News Transfer Protocol","135":"DCE endpoint resolution","139":"NETBIOS Session Service","143":"Reserved","144":"Universal Management Architecture","179":"BGP","199":"SMUX","443":"HTTPS","444":"Simple Network Paging Protocol","445":"Microsoft-DS","457":"scohelp","465":"IGMP over UDP for SSM","513":"maintains data bases showing who's logged in to machines on a local net and the load average of the machine","514":"rsh","515":"spooler","543":"Klogin","544":"krcmd","548":"AFP over TCP","554":"Real Time Streaming Protocol (RTSP)","587":"Message Submission","631":"Internet Printing Protocol over HTTPS","646":"LDP","6646":"IRC","873":"rsync","8880":"CDDBP","8888":"NewsEDGE server UDP (UDP 1)","990":"ftp protocol, control, over TLS/SSL","992":"telnet protocol over TLS/SSL","993":"Reserved","995":"pop3 protocol over TLS/SSL (was spop3)","1024":"Reserved","1025":"network blackjack","1026":"Calendar Access Protocol","1027":"Reserved","1028":"Deprecated","1029":"Solid Mux Server","1080":"Socks","1100":"MCTP","1110":"Client status info","1194":"OpenVPN","1241":"nessus","1352":"Lotus Note","1433":"Microsoft-SQL-Server","1434":"Microsoft-SQL-Monitor","1521":"nCube License Manager","1522":"Ricardo North America License Manager","15672":"RabbitMQ Mgmt","1720":"H.323 Call Control","1723":"pptp","1755":"ms-streaming","1900":"SSDP","1944":"close-combat","2000":"Cisco SCCp","2001":"curry","2049":"Network File System","2121":"SCIENTIA-SSDB","2222":"EtherNet/IP I/O","2301":"Compaq HTTP","2323":"3d-nfsd","2483":"Oracle TTC","2484":"Oracle TTC SSL","2638":"Sybase Anywhere","27017":"Reserved","27018":"MongoDB","27019":"MongoDB","2717":"PN REQUESTER","28015":"RethinkDB","3000":"RemoteWare Client","3050":"gds_db","3128":"Active API Server Port","32768":"Filenet TMS","3306":"MySQL","3389":"MS WBT Server","3986":"MAPPER workstation server","4000":"Terabase","4001":"NewOak","4002":"pxc-spvr-ft","4100":"IGo Incognito Data Port","4567":"TRAM","4899":"RAdmin Port","49152":"N/A","49153":"N/A","49154":"N/A","49155":"N/A","49156":"N/A","49157":"N/A","5000":"UPnP","5001":"N/A","5009":"Microsoft Windows Filesystem","5051":"ITA Agent","5060":"SIP","5101":"Talarian_UDP","5190":"America-Online","5357":"Web Services for Devices","5432":"PostgreSQL Database","5631":"pcANYWHEREdata","5666":"Reserved","5800":"VNC","5801":"VNC","5802":"VNC","5803":"VNC","5804":"VNC","5805":"VNC","5806":"VNC","5807":"VNC","5809":"VNC","5900":"Remote Framebuffer","5984":"CouchDB","5985":"WBEM WS-Management HTTP","5986":"WBEM WS-Management HTTP over TLS/SSL","6000":"X11","6001":"X11","6346":"gnutella-svc","6347":"gnutella-rtr","6379":"Reserved","6513":"Reserved","7000":"file server itself","7001":"callbacks to cache managers","7002":"users & groups database","7070":"ARCP","7170":"Adaptive Name/Service Resolution","7199":"Cassandra","7474":"Reserved","7647":"N/A","7687":"Reserved","7777":"cbt","8000":"iRDMI","8001":"VCOM Tunnel","8008":"HTTP Alternate","8009":"Reserved","8080":"HTTP Alternate (see port 80)","8081":"Sun Proxy Admin Service","8083":"Utilistor (Server)","8085":"Unassigned","8089":"Unassigned","8090":"Reserved","8181":"Reserved","8291":"MikroTik","8443":"PCsync HTTPS","9000":"CSlistener","9080":"Groove GLRPC","9090":"WebSM","9091":"xmltec-xmlmail","9092":"Xml-Ipc Server Reg","9100":"Printer PDL Data Stream","9200":"WAP connectionless session service","9443":"WSO2 Tungsten HTTPS","9990":"OSM Applet Server","9999":"distinct","10000":"Network Data Management Protocol","10080":"Amanda","10443":"Reserved","11211":"Memory cache service","20000":"Distributed Network Protocol","54321":"N/A","30821":"N/A","9042":"Cassandra CQL","9160":"apani1"};
          if (portServiceDB[port]) service = portServiceDB[port];
          if (!naabuMap[domain]) naabuMap[domain] = [];
          naabuMap[domain].push({ port, service });
          serviceCount[service] = (serviceCount[service] || 0) + 1;
        });
        window.naabuMap = naabuMap;
        const ctx = document.getElementById("serviceChart").getContext("2d");
        const sortedServices = Object.keys(serviceCount).sort((a, b) => serviceCount[b] - serviceCount[a]);
        const top10Services = sortedServices.slice(0, 10);
        const data = top10Services.map(service => serviceCount[service]);
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        serviceChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: top10Services,
            datasets: [{
              label: "Open Services",
              data,
              backgroundColor: "#6366f1",
              hoverBackgroundColor: "#4f46e5",
              borderRadius: 10,
              maxBarThickness: 36
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              x: {
                beginAtZero: true,
                ticks: {
                  color: chartText,
                  font: { family: tokens.fontFamily, weight: "500" },
                  maxRotation: 40,
                  minRotation: 0
                },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4], display: false }
              },
              y: {
                beginAtZero: true,
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildColleagueChart(colleagueData) {
        const countEmployee = colleagueData.filter(x => x.colleague_endpoint === "Yes").length;
        const countCustomer = colleagueData.length - countEmployee;
        const ctx = document.getElementById("colleagueEndpointChart").getContext("2d");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        colleagueChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["Employee Intended", "Customer Intended"],
            datasets: [{
              label: "Purpose Count",
              data: [countEmployee, countCustomer],
              backgroundColor: ["#38bdf8", "#34d399"],
              hoverBackgroundColor: ["#0ea5e9", "#22c55e"],
              borderRadius: 10,
              maxBarThickness: 42
            }]
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
              x: {
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4], display: false }
              },
              y: {
                beginAtZero: true,
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              }
            }
          }
        });
      }

      function buildNSChart(labels, data) {
        const trimmedLabels = labels.map(label => {
          const parts = label.split(".").filter(part => part.trim().length > 0);
          return parts.length > 3 ? parts.slice(-3).join(".") : label;
        });
        const top5Labels = trimmedLabels.slice(0, 5);
        const top5Data = data.slice(0, 5);
        const bgColors = ["#3b82f6", "#22c55e", "#a855f7", "#facc15", "#fb7185"];
        const ctx = document.getElementById("nsChart").getContext("2d");
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        nsChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: top5Labels,
            datasets: [{
              label: "Nameserver Summary",
              data: top5Data,
              backgroundColor: bgColors,
              borderRadius: 12,
              maxBarThickness: 32
            }]
          },
          options: {
            indexAxis: "y",
            responsive: true,
            plugins: {
              tooltip: { enabled: true },
              legend: { display: false }
            },
            scales: {
              x: {
                beginAtZero: true,
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, borderDash: [4, 4] }
              },
              y: {
                ticks: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } },
                grid: { color: tokens.grid, drawBorder: false, display: false }
              }
            }
          }
        });
      }

      // Global array to store table rows.
      let rowDataStore = [];

      // Build table rows
      function buildTableRows(combinedData, secMapDomain, secMapUrl, loginMap, apiMap, colleagueMap) {
        allTableRows = [];
        rowDataStore = [];
        Object.keys(combinedData).forEach(domain => {
          const { dns, http } = combinedData[domain];
          const dnsResolvers = dns && dns.resolver ? dns.resolver : [];
          const dnsA = dns && dns.a ? dns.a : [];
          const dnsStatus = dns ? dns.status_code : "N/A";
          const domainSec = secMapDomain[domain] || {};
          const spf = domainSec["SPF Record"] || "N/A";
          const dkim = domainSec["DKIM Record"] || "N/A";
          const dmarc = domainSec["DMARC Record"] || "N/A";
          const dnssec = domainSec["DNSSEC Status"] || "N/A";
          const nsRecords = (domainSec["NS Records"] || "N/A").replace(/\n/g, " ");
          const mxRecords = (domainSec["MX Records"] || "N/A").replace(/\n/g, " ");
          const ptrRecords = domainSec["PTR Record"] || "N/A";
          if (http && http.length) {
            http.forEach(h => {
              // Compute port and screenshot key for this record
              const port = h.port ? h.port : (h.url && h.url.startsWith("https") ? 443 : 80);
              const screenshotKey = domain + "_" + port;
              let screenshotHTML = "No screenshot";
              // Use the global screenshotMap defined earlier

              if (screenshotMap[screenshotKey]) {
                screenshotHTML = `
                  <span style="display:none;">has screenshot</span>
                  <img
                    src="${screenshotMap[screenshotKey]}"
                    class="thumbnail"
                    onclick="openModal('${screenshotMap[screenshotKey]}')"
                    alt="screenshot"
                  />
                `;
              } else {
                screenshotHTML = `
                  <span style="display:none;">no screenshot</span>
                  No screenshot
                `;
              }

              const urlSec = secMapUrl[h.url] || domainSec;
              const sslVersion = urlSec["SSL/TLS Version"] || "N/A";
              const certExpiry = urlSec["Cert Expiry Date"] || "N/A";
              const sslIssuer = urlSec["SSL/TLS Issuer"] || "N/A";
              const stsFlag = (urlSec["Strict-Transport-Security"] || "").trim();
              const xfoFlag = (urlSec["X-Frame-Options"] || "").trim();
              const cspFlag = (urlSec["Content-Security-Policy"] || "").trim();
              const xssFlag = (urlSec["X-XSS-Protection"] || "").trim();
              const rpFlag = (urlSec["Referrer-Policy"] || "").trim();
              const ppFlag = (urlSec["Permissions-Policy"] || "").trim();
              const techArr = Array.isArray(h.tech) ? h.tech : [];
              const sanitizedTech = techArr.map(item => item.replace(/\r?\n|\r/g, " ").trim());
              const techCount = sanitizedTech.length;
              const openPorts = (window.naabuMap && window.naabuMap[domain]) || [];
              const openPortsCount = openPorts.length;
              // Initialize counts for all three port categories
              let dbPortsCount = 0;
              let managementPortsCount = 0;

              openPorts.forEach(portObj => {
                const port = Number(portObj.port);

                // Database Ports (Expanded)
                if ([1433, 1434, 1521, 1522, 2483, 2484, 2638, 3050, 3306, 3389, 5432, 5984, 6379, 7000, 7199, 7474, 7687, 9042, 9160, 27017, 27018, 27019, 28015].includes(port)) {
                  dbPortsCount++;
                }

                // Management Ports (Expanded)
                if ([8000, 8008, 8080, 8081, 8083, 8089, 8090, 8443, 8880, 8888, 9000, 9090, 9091, 9092, 9100, 9990, 10000, 10080, 10443, 11211, 15672, 3000, 5000, 54321, 7001, 7002, 7070, 8181, 8800, 9200, 9443, 22, 23, 2222, 2323, 3389, 5900, 5800, 4899, 5631, 5666, 5985, 5986, 8291, 1723, 1194, 992, 6513, 5801, 5802, 5803, 5804, 5805, 5806, 5807, 5809].includes(port)) {
                  managementPortsCount++;
                }

              });

              const linksForUrl = (window.linksMap && window.linksMap[h.url]) ? window.linksMap[h.url] : [];
              const linkCount = linksForUrl.length;
              const linksCellHTML = linkCount > 0
                ? `<a href="#" onclick="openLinksModal('${h.url}'); return false;">${linkCount}</a>`
                : "N/A";

              const { score, debug } = computePriority({
                purpose: colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended",
                url: h.url,
                loginFound: loginMap[h.url] || "N/A",
                statusCode: h.status_code,
                sslVersion,
                certExpiry,
                sts: stsFlag,
                xfo: xfoFlag,
                csp: cspFlag,
                xss: xssFlag,
                rp: rpFlag,
                pp: ppFlag,
                openPortsCount: openPortsCount,
                dbPortsCount: dbPortsCount,
                managementPortsCount: managementPortsCount,
                techCount,
                linkCount
              });
              if (score < minRiskScore) minRiskScore = score;
              if (score > maxRiskScore) maxRiskScore = score;
              riskScores[domain] = score;
              rowDataStore.push({ domain, prioScore: score });
              const row = document.createElement("tr");
              row.innerHTML = `
                <td><!-- risk score cell --></td>
                <td>${domain}</td>
                <td>${colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended"}</td>
                <td>${formatCell(dnsResolvers)}</td>
                <td>${formatCell(dnsA)}</td>
                <td>${nsRecords}</td>
                <td>${mxRecords}</td>
                <td>${ptrRecords}</td>
                <td>${dnsStatus}</td>
                <td>${h.cdn_name || "N/A"}</td>
                <td>${h.cdn_type || "N/A"}</td>
                <td>${h.port || "N/A"}</td>
                <td>${h.url || "N/A"}</td>
                <td>${screenshotHTML}</td>
                <td>${h.location || "N/A"}</td>
                <td>${h.title || "N/A"}</td>
                <td>${h.webserver || "N/A"}</td>
                <td>${loginMap[h.url] || "N/A"}</td>
                <td>${apiMap[domain] || "No"}</td>
                <td>${sanitizedTech.length ? sanitizedTech.join("<br>") : "N/A"}</td>
                <td>${(h.status_code !== undefined) ? h.status_code : "N/A"}</td>
                <td>${(h.content_length !== undefined) ? h.content_length : "N/A"}</td>
                <td>${(h.cdn !== undefined) ? h.cdn : "N/A"}</td>
                <td>${spf}</td>
                <td>${dkim}</td>
                <td>${dmarc}</td>
                <td>${dnssec}</td>
                <td>${sslVersion}</td>
                <td>${certExpiry}</td>
                <td>${sslIssuer}</td>
                <td>${stsFlag ? "True" : "False"}</td>
                <td>${xfoFlag ? "True" : "False"}</td>
                <td>${cspFlag ? "True" : "False"}</td>
                <td>${xssFlag ? "True" : "False"}</td>
                <td>${rpFlag ? "True" : "False"}</td>
                <td>${ppFlag ? "True" : "False"}</td>
                <td>${
                  (window.naabuMap && window.naabuMap[domain])
                  ? window.naabuMap[domain].map(p => `${p.port} (${p.service})`).join("<br>")
                  : "N/A"
                }</td>
                <td>${linksCellHTML}</td>
              `;
              const scoreCell = row.getElementsByTagName("td")[0];
              scoreCell.innerText = score;
              scoreCell.title = debug.join("\n");
              prepareRowCells(row);
              allTableRows.push(row);
            });
          }
          else {
            // If no HTTP data for domain, create a default row.
            const row = document.createElement("tr");
            row.innerHTML = `
              <td>N/A</td>
              <td>${domain}</td>
              <td>${colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended"}</td>
              <td>${formatCell(dnsResolvers)}</td>
              <td>${formatCell(dnsA)}</td>
              <td>${nsRecords}</td>
              <td>${mxRecords}</td>
              <td>${ptrRecords}</td>
              <td>${dnsStatus}</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>No screenshot</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>${spf}</td>
              <td>${dkim}</td>
              <td>${dmarc}</td>
              <td>${dnssec}</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
            `;
            prepareRowCells(row);
            allTableRows.push(row);
          }
        });
      }

      function finalizeColors() {
        allTableRows.forEach(row => {
          const cells = row.getElementsByTagName("td");
          const scoreCell = cells[0];
          if (scoreCell.innerText === "N/A") return;
          const prioScore = parseInt(scoreCell.innerText, 10) || 0;
          const color = getDynamicColor(prioScore, minRiskScore, maxRiskScore);
          scoreCell.style.backgroundColor = color;
          scoreCell.style.color = "#fff";
        });
      }

      // Update filtering – note that we add a check for screenshot filter in column index 13.
      function getFilteredRows() {
        const query = document.getElementById("searchBox").value.toLowerCase();
        const filters = {
          priority: document.getElementById("priority-filter").value.toLowerCase(),
          domain: document.getElementById("domain-filter").value.toLowerCase(),
          purpose: document.getElementById("purpose-filter").value.toLowerCase(),
          resolvers: document.getElementById("resolvers-filter").value.toLowerCase(),
          arecords: document.getElementById("arecords-filter").value.toLowerCase(),
          ns: document.getElementById("ns-filter").value.toLowerCase(),
          mx: document.getElementById("mx-filter").value.toLowerCase(),
          ptr: document.getElementById("ptr-filter").value.toLowerCase(),
          dnsstatus: document.getElementById("dnsstatus-filter").value.toLowerCase(),
          cdnname: document.getElementById("cdnname-filter").value.toLowerCase(),
          cdntype: document.getElementById("cdntype-filter").value.toLowerCase(),
          port: document.getElementById("port-filter").value.toLowerCase(),
          url: document.getElementById("url-filter").value.toLowerCase(),
          screenshot: document.getElementById("screenshot-filter").value.toLowerCase(),
          location: document.getElementById("redirect-filter").value.toLowerCase(),
          title: document.getElementById("title-filter").value.toLowerCase(),
          webserver: document.getElementById("webserver-filter").value.toLowerCase(),
          login: document.getElementById("login-filter").value.toLowerCase(),
          apiEndpoint: document.getElementById("api-endpoint-filter").value.toLowerCase(),
          tech: document.getElementById("tech-filter").value.toLowerCase(),
          statuscode: document.getElementById("statuscode-filter").value.toLowerCase(),
          contentlength: document.getElementById("contentlength-filter").value.toLowerCase(),
          cdn: document.getElementById("cdn-filter").value.toLowerCase(),
          spf: document.getElementById("spf-filter").value.toLowerCase(),
          dkim: document.getElementById("dkim-filter").value.toLowerCase(),
          dmarc: document.getElementById("dmarc-filter").value.toLowerCase(),
          dnssec: document.getElementById("dnssec-filter").value.toLowerCase(),
          sslversion: document.getElementById("sslversion-filter").value.toLowerCase(),
          certexpiry: document.getElementById("certexpiry-filter").value.toLowerCase(),
          sslissuer: document.getElementById("sslissuer-filter").value.toLowerCase(),
          sts: document.getElementById("sts-filter").value.toLowerCase(),
          xfo: document.getElementById("xfo-filter").value.toLowerCase(),
          csp: document.getElementById("csp-filter").value.toLowerCase(),
          xss: document.getElementById("xss-filter").value.toLowerCase(),
          rp: document.getElementById("rp-filter").value.toLowerCase(),
          pp: document.getElementById("pp-filter").value.toLowerCase(),
          portsservices: document.getElementById("ports-services-filter").value.toLowerCase(),
          crawledlinks: document.getElementById("crawledlinks-filter").value.toLowerCase()

        };
        const filtered = allTableRows.filter(row => {
          const cells = Array.from(row.getElementsByTagName("td"));
          const cellTexts = cells.map(cell => getCellContentText(cell).toLowerCase());
          if (filters.priority && !(cellTexts[0] || "").includes(filters.priority)) return false;
          if (filters.domain && !(cellTexts[1] || "").includes(filters.domain)) return false;
          if (filters.purpose && !(cellTexts[2] || "").includes(filters.purpose)) return false;
          if (filters.resolvers && !(cellTexts[3] || "").includes(filters.resolvers)) return false;
          if (filters.arecords && !(cellTexts[4] || "").includes(filters.arecords)) return false;
          if (filters.ns && !(cellTexts[5] || "").includes(filters.ns)) return false;
          if (filters.mx && !(cellTexts[6] || "").includes(filters.mx)) return false;
          if (filters.ptr && !(cellTexts[7] || "").includes(filters.ptr)) return false;
          if (filters.dnsstatus && !(cellTexts[8] || "").includes(filters.dnsstatus)) return false;
          if (filters.cdnname && !(cellTexts[9] || "").includes(filters.cdnname)) return false;
          if (filters.cdntype && !(cellTexts[10] || "").includes(filters.cdntype)) return false;
          if (filters.port && !(cellTexts[11] || "").includes(filters.port)) return false;
          if (filters.url && !(cellTexts[12] || "").includes(filters.url)) return false;
          const screenshotFilter = filters.screenshot;
          if (screenshotFilter) {
            const screenshotCell = cells[13];
            const hasImage = !!(screenshotCell && screenshotCell.querySelector("img"));
            if (screenshotFilter === "has screenshot" && !hasImage) return false;
            if (screenshotFilter === "no screenshot" && hasImage) return false;
          }
          if (filters.location && !(cellTexts[14] || "").includes(filters.location)) return false;
          if (filters.title && !(cellTexts[15] || "").includes(filters.title)) return false;
          if (filters.webserver && !(cellTexts[16] || "").includes(filters.webserver)) return false;
          if (filters.login && !(cellTexts[17] || "").includes(filters.login)) return false;
          if (filters.apiEndpoint && !(cellTexts[18] || "").includes(filters.apiEndpoint)) return false;
          if (filters.tech && !(cellTexts[19] || "").includes(filters.tech)) return false;
          if (filters.statuscode && !(cellTexts[20] || "").includes(filters.statuscode)) return false;
          if (filters.contentlength && !(cellTexts[21] || "").includes(filters.contentlength)) return false;
          if (filters.cdn && !(cellTexts[22] || "").includes(filters.cdn)) return false;
          if (filters.spf && !(cellTexts[23] || "").includes(filters.spf)) return false;
          if (filters.dkim && !(cellTexts[24] || "").includes(filters.dkim)) return false;
          if (filters.dmarc && !(cellTexts[25] || "").includes(filters.dmarc)) return false;
          if (filters.dnssec && !(cellTexts[26] || "").includes(filters.dnssec)) return false;
          if (filters.sslversion && !(cellTexts[27] || "").includes(filters.sslversion)) return false;
          if (filters.certexpiry && !(cellTexts[28] || "").includes(filters.certexpiry)) return false;
          if (filters.sslissuer && !(cellTexts[29] || "").includes(filters.sslissuer)) return false;
          if (filters.sts && !(cellTexts[30] || "").includes(filters.sts)) return false;
          if (filters.xfo && !(cellTexts[31] || "").includes(filters.xfo)) return false;
          if (filters.csp && !(cellTexts[32] || "").includes(filters.csp)) return false;
          if (filters.xss && !(cellTexts[33] || "").includes(filters.xss)) return false;
          if (filters.rp && !(cellTexts[34] || "").includes(filters.rp)) return false;
          if (filters.pp && !(cellTexts[35] || "").includes(filters.pp)) return false;
          if (filters.portsservices && !(cellTexts[36] || "").includes(filters.portsservices)) return false;
          if (filters.crawledlinks && !(cellTexts[37] || "").includes(filters.crawledlinks)) return false;
          if (query) {
            const rowText = cellTexts.join(" ");
            if (!rowText.includes(query)) return false;
          }
          return true;
        });
        filtered.sort((a, b) => {
          const scoreA = parseInt(a.cells[0].innerText) || 0;
          const scoreB = parseInt(b.cells[0].innerText) || 0;
          return riskSortOrder === "asc" ? scoreA - scoreB : scoreB - scoreA;
        });
        return filtered;
      }

      function renderTable(filteredRows) {
        const tBody = document.getElementById("report-table-body");
        tBody.innerHTML = "";
        let startIndex = 0;
        let endIndex = filteredRows.length;
        if (rowsPerPage !== "all" && rowsPerPage !== Infinity) {
          startIndex = (currentPage - 1) * rowsPerPage;
          endIndex = startIndex + rowsPerPage;
        }
        const rowsToShow = filteredRows.slice(startIndex, endIndex);
        rowsToShow.forEach(row => {
          prepareRowCells(row);
          tBody.appendChild(row);
        });
        window.requestAnimationFrame(() => updateClampStates(rowsToShow));
        renderPaginationControls(filteredRows.length);
      }

      function renderPaginationControls(totalRows) {
        const paginationDiv = document.getElementById("paginationControls");
        paginationDiv.innerHTML = "";
        if (rowsPerPage === "all" || rowsPerPage === Infinity) return;
        const totalPages = Math.ceil(totalRows / rowsPerPage);
        const pageInfo = document.createElement("span");
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
        paginationDiv.appendChild(pageInfo);
        const prevBtn = document.createElement("button");
        prevBtn.textContent = "Prev";
        prevBtn.disabled = currentPage === 1;
        prevBtn.addEventListener("click", () => {
          if (currentPage > 1) {
            currentPage--;
            renderTable(getFilteredRows());
          }
        });
        paginationDiv.appendChild(prevBtn);
        const nextBtn = document.createElement("button");
        nextBtn.textContent = "Next";
        nextBtn.disabled = currentPage === totalPages;
        nextBtn.addEventListener("click", () => {
          if (currentPage < totalPages) {
            currentPage++;
            renderTable(getFilteredRows());
          }
        });
        paginationDiv.appendChild(nextBtn);
      }

      function onFilterChange() {
        currentPage = 1;
        renderTable(getFilteredRows());
      }

      function updateRowsPerPage() {
        const select = document.getElementById("rowsPerPageSelect");
        const value = select.value;
        rowsPerPage = value === "all" ? Infinity : parseInt(value, 10);
        currentPage = 1;
        renderTable(getFilteredRows());
      }

      function populateColumnFilters() {
        const uniqueCols = Array.from({ length: 38 }, () => new Set());
        allTableRows.forEach(row => {
          const cells = row.getElementsByTagName("td");
          for (let col = 0; col < 38; col++) {
            const cell = cells[col];
            if (!cell) continue;
            if (col === 13) {
              const hasImage = !!cell.querySelector("img");
              uniqueCols[col].add(hasImage ? "Has screenshot" : "No screenshot");
            } else {
              const text = getCellContentText(cell);
              if (text) uniqueCols[col].add(text);
            }
          }
        });
        function fillSelectOptions(selectId, values) {
          const select = document.getElementById(selectId);
          const existing = select.querySelectorAll("option:not([value=''])");
          existing.forEach(opt => opt.remove());
          if (selectId === "priority-filter") {
            values = values.filter(v => !isNaN(v)).sort((a, b) => b - a);
          } else {
            values.sort();
          }
          values.forEach(val => {
            if (val.toLowerCase() === "asc" || val.toLowerCase() === "desc") return;
            const option = document.createElement("option");
            option.value = val;
            option.textContent = val;
            select.appendChild(option);
          });
        }
        fillSelectOptions("priority-filter", [...uniqueCols[0]]);
        fillSelectOptions("domain-filter", [...uniqueCols[1]]);
        fillSelectOptions("purpose-filter", [...uniqueCols[2]]);
        fillSelectOptions("resolvers-filter", [...uniqueCols[3]]);
        fillSelectOptions("arecords-filter", [...uniqueCols[4]]);
        fillSelectOptions("ns-filter", [...uniqueCols[5]]);
        fillSelectOptions("mx-filter", [...uniqueCols[6]]);
        fillSelectOptions("ptr-filter", [...uniqueCols[7]]);
        fillSelectOptions("dnsstatus-filter", [...uniqueCols[8]]);
        fillSelectOptions("cdnname-filter", [...uniqueCols[9]]);
        fillSelectOptions("cdntype-filter", [...uniqueCols[10]]);
        fillSelectOptions("port-filter", [...uniqueCols[11]]);
        fillSelectOptions("url-filter", [...uniqueCols[12]]);
        fillSelectOptions("screenshot-filter", [...uniqueCols[13]]);
        fillSelectOptions("redirect-filter", [...uniqueCols[14]]);
        fillSelectOptions("title-filter", [...uniqueCols[15]]);
        fillSelectOptions("webserver-filter", [...uniqueCols[16]]);
        fillSelectOptions("login-filter", [...uniqueCols[17]]);
        fillSelectOptions("api-endpoint-filter", [...uniqueCols[18]]);
        fillSelectOptions("tech-filter", [...uniqueCols[19]]);
        fillSelectOptions("statuscode-filter", [...uniqueCols[20]]);
        fillSelectOptions("contentlength-filter", [...uniqueCols[21]]);
        fillSelectOptions("cdn-filter", [...uniqueCols[22]]);
        fillSelectOptions("spf-filter", [...uniqueCols[23]]);
        fillSelectOptions("dkim-filter", [...uniqueCols[24]]);
        fillSelectOptions("dmarc-filter", [...uniqueCols[25]]);
        fillSelectOptions("dnssec-filter", [...uniqueCols[26]]);
        fillSelectOptions("sslversion-filter", [...uniqueCols[27]]);
        fillSelectOptions("certexpiry-filter", [...uniqueCols[28]]);
        fillSelectOptions("sslissuer-filter", [...uniqueCols[29]]);
        fillSelectOptions("sts-filter", [...uniqueCols[30]]);
        fillSelectOptions("xfo-filter", [...uniqueCols[31]]);
        fillSelectOptions("csp-filter", [...uniqueCols[32]]);
        fillSelectOptions("xss-filter", [...uniqueCols[33]]);
        fillSelectOptions("rp-filter", [...uniqueCols[34]]);
        fillSelectOptions("pp-filter", [...uniqueCols[35]]);
        fillSelectOptions("ports-services-filter", [...uniqueCols[36]]);
        fillSelectOptions("crawledlinks-filter", [...uniqueCols[37]]);
      }

      document.getElementById("searchBox").addEventListener("input", onFilterChange);
      document.getElementById("rowsPerPageSelect").addEventListener("change", updateRowsPerPage);
      document.getElementById("riskSortToggle").addEventListener("click", function() {
        riskSortOrder = (riskSortOrder === "asc") ? "desc" : "asc";
        this.textContent = (riskSortOrder === "asc") ? "▲" : "▼";
        renderTable(getFilteredRows());
      });

      // Async data loading and report building
      async function loadData() {
        try {
