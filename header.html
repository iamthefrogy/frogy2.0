<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>External Attack Surface Analysis</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="assets/report.css" />
    <style>
      .summary-card {
        background: var(--color-surface);
        border-radius: var(--radius-lg);
        border: 1px solid var(--color-border);
        padding: 24px 26px;
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .summary-card__header {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
      }
      .summary-card__header h2 {
        margin: 0;
        font-size: clamp(20px, 2.2vw, 24px);
        font-weight: 600;
        letter-spacing: -0.01em;
      }
      .summary-card__timestamp {
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--color-text-muted);
      }
      .summary-card__headline {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        gap: 12px;
      }
      .summary-card__risk-label {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.14em;
        text-transform: uppercase;
        color: var(--color-text-muted);
      }
      .summary-card__risk-score {
        font-size: clamp(30px, 4vw, 30px);
        font-weight: 700;
        color: var(--color-danger);
      }
      .summary-card__risk-asset {
        font-size: clamp(16px, 2.1vw, 20px);
        font-weight: 600;
        color: var(--color-text);
      }
      .summary-card__pipeline {
        margin: 0;
        font-size: 14px;
        font-weight: 500;
        color: var(--color-text-muted);
      }
      .summary-card__actions {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin: 0;
      }
      .summary-card__actions span {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: var(--color-text-muted);
      }
      .summary-card__actions ul {
        margin: 0;
        padding-left: 18px;
        display: grid;
        gap: 4px;
        font-size: 12px;
      }
      .summary-card__meta {
        margin: 0;
        font-size: 12px;
        color: var(--color-text-muted);
      }
      .score-card__label {
        margin: 0;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        color: var(--color-text-muted);
      }
      .score-card__meta {
        margin: 0;
        font-size: 12px;
        color: var(--color-text-muted);
      }
      .score-card__context {
        margin: 0;
        font-size: 12px;
        color: var(--color-text-muted);
        opacity: 0.85;
      }
      .scoreboard__section {
        display: flex;
        flex-direction: column;
      }
      .scoreboard__section-title {
        margin: 15;
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: var(--color-text-muted);
      }
      .scoreboard__grid--kpis {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }
      @media (min-width: 1200px) {
        .scoreboard__grid--kpis {
          grid-template-columns: repeat(4, minmax(0, 1fr));
        }
      }
      .score-card--danger h2 {
        color: var(--color-danger);
      }
      .score-card--warning h2 {
        color: #f59e0b;
      }
      .score-card--success h2 {
        color: var(--color-accent);
      }
      .score-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 4px 12px;
        border-radius: 999px;
        font-size: 15px;
        font-weight: 700;
        color: #fff;
        background: #3b82f6;
        min-width: 44px;
      }
      .score-badge--moderate {
        background: #3b82f6;
      }
      .score-badge--high {
        background: #f97316;
      }

      .score-badge--low {
        background: #10b981;
      }
      .chip-group {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 8px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 10px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 600;
        background: var(--color-surface-muted);
        color: var(--color-text);
        border: 1px solid var(--color-border);
        white-space: nowrap;
      }
      .chip small {
        font-size: 10px;
        font-weight: 700;
        opacity: 0.7;
      }
      .chip--danger {
        background: rgba(239, 68, 68, 0.14);
        color: #b91c1c;
        border-color: rgba(239, 68, 68, 0.35);
      }
      .chip--warning {
        background: rgba(249, 115, 22, 0.16);
        color: #c2410c;
        border-color: rgba(249, 115, 22, 0.35);
      }
      .chip--info {
        background: rgba(59, 130, 246, 0.16);
        color: #1d4ed8;
        border-color: rgba(59, 130, 246, 0.32);
      }
      .table-top-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 16px;
        padding: 8px 0;
      }
      .table-top-controls input[type="text"] {
        min-width: 420px;
        padding: 10px 12px;
        border-radius: var(--radius-sm);
        border: 1px solid var(--color-border);
        font-size: 14px;
        color: var(--color-text);
        background: var(--color-surface-muted);
      }
      .table-top-controls input[type="text"]:focus {
        outline: none;
        background: var(--color-surface);
        border-color: var(--color-primary);
        box-shadow: 0 0 0 3px var(--color-primary-soft);
      }
      .table-top-controls .hint {
        flex: 1 1 260px;
        min-width: 500px;
        text-align: left;
      }
      .table-top-controls .table-controls {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 8px;
      }
    </style>
    <script>
      const screenshotMap =
      %%SCREENSHOT_MAP%%
      ;
    </script>
  </head>
  <body>
    <header class="header">
      <div class="header__content">
        <div class="header__titles">
          <h1>External Attack Surface Intelligence Report</h1>
          <p class="header__subtitle">Unified visibility across internet-exposed assets, live services, and defensive readiness indicators.</p>
        </div>
        <div class="header__actions">
          <button id="themeToggleButton" class="btn btn--ghost theme-toggle" type="button" aria-pressed="false" title="Switch to dark theme">Dark theme</button>
          <button id="exportCsvButton" class="btn btn--primary" type="button">Export CSV</button>
        </div>
      </div>
    </header>

    <main class="container">
      <section class="scoreboard" id="scoreboard"></section>

      <section class="charts-grid">
        <div class="chart-container"><h3>Discovery Summary</h3><canvas id="funnelChart"></canvas></div>
        <div class="chart-container"><h3>Risk Leaderboard</h3><canvas id="riskLeaderboardChart"></canvas></div>
        <div class="chart-container"><h3>DNS Health</h3><canvas id="dnsHealthChart"></canvas></div>
        <div class="chart-container"><h3>Endpoint vs Login Exposure</h3><canvas id="tlsLoginChart"></canvas></div>
        <div class="chart-container"><h3>HTTP Status Distribution</h3><canvas id="statusCodeChart"></canvas></div>
        <div class="chart-container"><h3>Security Header Coverage</h3><canvas id="headerCoverageChart"></canvas></div>
        <div class="chart-container"><h3>Email Authentication</h3><canvas id="emailCoverageChart"></canvas></div>
        <div class="chart-container"><h3>Top 10 Technologies Observed</h3><canvas id="techChart"></canvas></div>
      </section>

      <section class="table-top-controls">
        <input type="text" id="searchBox" placeholder="Filter results (domain, status code, technology…)" />
        <div class="hint">Hover the Attack Surface Score to review the contextual risk factors.</div>
        <div class="table-controls">
          <label for="rowsPerPageSelect">Rows per page</label>
          <select id="rowsPerPageSelect">
            <option value="20">20</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="all">ALL</option>
          </select>
        </div>
      </section>

      <div class="table-container">
        <table id="report-table">
          <thead>
            <tr>
              <th id="riskScoreHeader">Attack Surface Score<span id="riskSortToggle">▼</span></th>
              <th>Domain</th>
              <th>Purpose</th>
              <th>Resolvers</th>
              <th>A Records</th>
              <th>NS Records</th>
              <th>MX Records</th>
              <th>PTR Records</th>
              <th>DNS Status</th>
              <th>CDN Name</th>
              <th>CDN Type</th>
              <th>Port</th>
              <th>URL</th>
              <th>Screenshot</th>
              <th>Redirect Location</th>
              <th>Homepage Title</th>
              <th>Web Server</th>
              <th>Login Found</th>
              <th>API Endpoint</th>
              <th>Technology Stack</th>
              <th>Status Code</th>
              <th>Content Length</th>
              <th>CDN</th>
              <th>SPF Record</th>
              <th>DKIM Record</th>
              <th>DMARC Record</th>
              <th>DNSSEC Record</th>
              <th>SSL/TLS Version</th>
              <th>Cert Expiry Date</th>
              <th>SSL/TLS Issuer</th>
              <th>Strict-Transport-Security</th>
              <th>X-Frame-Options</th>
              <th>Content-Security-Policy</th>
              <th>X-XSS-Protection</th>
              <th>Referrer Policy</th>
              <th>Permissions Policy</th>
              <th>Open Ports / Services</th>
              <th>Crawled Links</th>
            </tr>
            <tr id="filter-row">
              <th><select id="priority-filter"><option value="">All</option></select></th>
              <th><select id="domain-filter"><option value="">All</option></select></th>
              <th><select id="purpose-filter"><option value="">All</option></select></th>
              <th><select id="resolvers-filter"><option value="">All</option></select></th>
              <th><select id="arecords-filter"><option value="">All</option></select></th>
              <th><select id="ns-filter"><option value="">All</option></select></th>
              <th><select id="mx-filter"><option value="">All</option></select></th>
              <th><select id="ptr-filter"><option value="">All</option></select></th>
              <th><select id="dnsstatus-filter"><option value="">All</option></select></th>
              <th><select id="cdnname-filter"><option value="">All</option></select></th>
              <th><select id="cdntype-filter"><option value="">All</option></select></th>
              <th><select id="port-filter"><option value="">All</option></select></th>
              <th><select id="url-filter"><option value="">All</option></select></th>
              <th>
                <select id="screenshot-filter">
                  <option value="">All</option>
                  <option value="has screenshot">Has screenshot</option>
                  <option value="no screenshot">No screenshot</option>
                </select>
              </th>
              <th><select id="redirect-filter"><option value="">All</option></select></th>
              <th><select id="title-filter"><option value="">All</option></select></th>
              <th><select id="webserver-filter"><option value="">All</option></select></th>
              <th><select id="login-filter"><option value="">All</option></select></th>
              <th><select id="api-endpoint-filter"><option value="">All</option></select></th>
              <th><select id="tech-filter"><option value="">All</option></select></th>
              <th><select id="statuscode-filter"><option value="">All</option></select></th>
              <th><select id="contentlength-filter"><option value="">All</option></select></th>
              <th><select id="cdn-filter"><option value="">All</option></select></th>
              <th><select id="spf-filter"><option value="">All</option></select></th>
              <th><select id="dkim-filter"><option value="">All</option></select></th>
              <th><select id="dmarc-filter"><option value="">All</option></select></th>
              <th><select id="dnssec-filter"><option value="">All</option></select></th>
              <th><select id="sslversion-filter"><option value="">All</option></select></th>
              <th><select id="certexpiry-filter"><option value="">All</option></select></th>
              <th><select id="sslissuer-filter"><option value="">All</option></select></th>
              <th><select id="sts-filter"><option value="">All</option></select></th>
              <th><select id="xfo-filter"><option value="">All</option></select></th>
              <th><select id="csp-filter"><option value="">All</option></select></th>
              <th><select id="xss-filter"><option value="">All</option></select></th>
              <th><select id="rp-filter"><option value="">All</option></select></th>
              <th><select id="pp-filter"><option value="">All</option></select></th>
              <th><select id="ports-services-filter"><option value="">All</option></select></th>
              <th><select id="crawledlinks-filter"><option value="">All</option></select></th>
            </tr>
          </thead>
          <tbody id="report-table-body"></tbody>
        </table>
      </div>
      <div id="paginationControls"></div>

      <div id="screenshotModal">
        <div id="screenshotModalContent">
          <button id="closeModalBtn" onclick="closeModal()" aria-label="Close screenshot viewer">&times;</button>
          <img id="screenshotModalImg" src="" alt="Full Screenshot" />
        </div>
      </div>

      <div id="linksModal">
        <div>
          <button onclick="closeLinksModal()" aria-label="Close links viewer">&times;</button>
          <div id="linksModalBody"></div>
        </div>
      </div>
    </main>
    <script>
      // Plugin for displaying labels on bars in charts
      const barLabelPlugin = {
        id: 'barLabelPlugin',
        afterDatasetsDraw(chart, args, options) {
          const { ctx } = chart;
          const metaSets = chart.getSortedVisibleDatasetMetas().filter(m => m.type === 'bar');
          const tokens = getDesignTokens();
          const labelColor = getChartTextColor(tokens);
          metaSets.forEach(meta => {
            meta.data.forEach((element, index) => {
              const parsed = meta._parsed && meta._parsed[index];
              let value = typeof parsed === "object" && parsed !== null
                ? parsed[meta.vScale.axis]
                : parsed;
              if (value === undefined || value === null) {
                const dataset = meta._dataset && Array.isArray(meta._dataset.data)
                  ? meta._dataset.data[index]
                  : undefined;
                if (typeof dataset === "object" && dataset !== null) {
                  value = dataset[meta.vScale?.axis] ?? dataset.y ?? dataset;
                } else {
                  value = dataset;
                }
              }
              if (value === 0) return;
              const { x, y } = element.tooltipPosition();
              ctx.save();
              ctx.fillStyle = labelColor;
              ctx.font = options.font || '9px sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              ctx.fillText(value, x, y - 2);
              ctx.restore();
            });
          });
        }
      };
      Chart.register(barLabelPlugin);

      const DATABASE_PORTS = new Set([1433, 1434, 1521, 1522, 2483, 2484, 2638, 3050, 3306, 3389, 5432, 5984, 6379, 7000, 7199, 7474, 7687, 9042, 9160, 27017, 27018, 27019, 28015]);
      const MANAGEMENT_PORTS = new Set([8000, 8008, 8080, 8081, 8083, 8089, 8090, 8443, 8880, 8888, 9000, 9090, 9091, 9092, 9100, 9990, 10000, 10080, 10443, 11211, 15672, 3000, 5000, 54321, 7001, 7002, 7070, 8181, 8800, 9200, 9443, 22, 23, 2222, 2323, 3389, 5900, 5800, 4899, 5631, 5666, 5985, 5986, 8291, 1723, 1194, 992, 6513, 5801, 5802, 5803, 5804, 5805, 5806, 5807, 5809]);
      const WEB_PORTS = new Set([80, 443, 8000, 8008, 8080, 8081, 8083, 8089, 8090, 8443, 8880, 8888, 9200, 9443]);
      const EMAIL_TRANSPORT_PORTS = new Set([25, 26, 465, 587]);
      const EMAIL_ACCESS_PORTS = new Set([110, 143, 993, 995]);
      const DNS_PORTS = new Set([53]);
      const FTP_PORTS = new Set([20, 21]);

      const THEME_STORAGE_KEY = "report-theme-preference";
      const themeToggleButton = document.getElementById("themeToggleButton");
      setTheme(readStoredTheme() || "light", false);
      configureThemeToggle();

      function getDesignTokens() {
        const styles = getComputedStyle(document.body);
        const readToken = (token, fallback) => {
          const value = styles.getPropertyValue(token);
          return value ? value.trim() || fallback : fallback;
        };
        const fontToken = readToken("--font-family-base", "Inter, system-ui, sans-serif");
        return {
          text: readToken("--color-text", "#0f172a"),
          muted: readToken("--color-text-muted", "#475569"),
          border: readToken("--color-border", "rgba(15, 23, 42, 0.18)"),
          grid: readToken("--color-gridline", "rgba(148, 163, 184, 0.22)"),
          fontFamily: fontToken.replace(/['"]/g, "").trim() || "Inter, system-ui, sans-serif"
        };
      }

      function getChartTextColor(tokens) {
        return tokens.text;
      }
      function getTooltipTheme(tokens) {
        const isDark = (document.body.dataset.theme || "light") === "dark";
        return {
          backgroundColor: isDark ? "rgba(15, 23, 42, 0.92)" : "#f8fafc",
          titleColor: tokens.text,
          bodyColor: tokens.text,
          borderColor: isDark ? "rgba(148, 163, 184, 0.32)" : "rgba(15, 23, 42, 0.18)",
          borderWidth: 1,
          displayColors: false,
          padding: 10
        };
      }

      function setTheme(theme, persist = true) {
        const normalized = theme === "dark" ? "dark" : "light";
        document.body.dataset.theme = normalized;
        if (themeToggleButton) {
          themeToggleButton.textContent = normalized === "dark" ? "Light theme" : "Dark theme";
          themeToggleButton.setAttribute("aria-pressed", normalized === "dark" ? "true" : "false");
          themeToggleButton.title = normalized === "dark" ? "Switch to light theme" : "Switch to dark theme";
        }
        if (persist) {
          storeTheme(normalized);
        }
      }

      function configureThemeToggle() {
        if (!themeToggleButton) return;
        themeToggleButton.addEventListener("click", () => {
          const nextTheme = document.body.dataset.theme === "dark" ? "light" : "dark";
          setTheme(nextTheme);
          refreshThemeTokens();
        });
      }

      function applyChartDefaults() {
        const tokens = getDesignTokens();
        const chartText = getChartTextColor(tokens);
        Chart.defaults.font.family = tokens.fontFamily;
        Chart.defaults.font.size = 12;
        Chart.defaults.font.weight = "500";
        Chart.defaults.color = chartText;
        Chart.defaults.borderColor = tokens.grid;
        if (Chart.defaults.plugins?.legend?.labels) {
          Chart.defaults.plugins.legend.labels.color = chartText;
          Chart.defaults.plugins.legend.labels.font = Chart.defaults.plugins.legend.labels.font || {};
          Chart.defaults.plugins.legend.labels.font.family = tokens.fontFamily;
          Chart.defaults.plugins.legend.labels.font.weight = "500";
        }
        if (Chart.defaults.plugins?.tooltip) {
          Chart.defaults.plugins.tooltip.titleColor = chartText;
          Chart.defaults.plugins.tooltip.bodyColor = chartText;
          Chart.defaults.plugins.tooltip.titleFont = Chart.defaults.plugins.tooltip.titleFont || {};
          Chart.defaults.plugins.tooltip.bodyFont = Chart.defaults.plugins.tooltip.bodyFont || {};
          Chart.defaults.plugins.tooltip.titleFont.family = tokens.fontFamily;
          Chart.defaults.plugins.tooltip.titleFont.weight = "600";
          Chart.defaults.plugins.tooltip.bodyFont.family = tokens.fontFamily;
          Chart.defaults.plugins.tooltip.bodyFont.weight = "500";
        }
        return tokens;
      }

      applyChartDefaults();

      function refreshThemeTokens() {
        const tokens = applyChartDefaults();
        [
          funnelChart,
          riskLeaderboardChart,
          dnsHealthChart,
          tlsLoginChart,
          statusCodeChart,
          headerCoverageChart,
          emailCoverageChart,
          techChart
        ].filter(Boolean).forEach(chart => updateChartAppearance(chart, tokens));
      }

      function updateChartAppearance(chart, tokens) {
        if (!chart || !chart.options) return;
        const { options } = chart;
        if (options.scales) {
          Object.values(options.scales).forEach(scale => {
            if (!scale) return;
            if (scale.ticks) {
              const currentFont = scale.ticks.font || {};
              scale.ticks.color = tokens.text;
              scale.ticks.font = Object.assign({}, currentFont, {
                family: tokens.fontFamily,
                weight: currentFont.weight || "500"
              });
            }
            if (scale.grid) {
              scale.grid.color = tokens.grid;
            }
          });
        }
        if (options.plugins?.legend?.labels) {
          const legendFont = options.plugins.legend.labels.font || {};
          options.plugins.legend.labels.color = tokens.text;
          options.plugins.legend.labels.font = Object.assign({}, legendFont, {
            family: tokens.fontFamily,
            weight: legendFont.weight || "500"
          });
        }
        if (options.plugins?.tooltip) {
          const tooltipTheme = getTooltipTheme(tokens);
          options.plugins.tooltip = Object.assign({}, options.plugins.tooltip, tooltipTheme);
        }
        chart.update("none");
      }

      function storeTheme(value) {
        try {
          localStorage.setItem(THEME_STORAGE_KEY, value);
        } catch {}
      }

      function readStoredTheme() {
        try {
          return localStorage.getItem(THEME_STORAGE_KEY);
        } catch {
          return null;
        }
      }

      // Global variables for charts and table data.
      let funnelChart, riskLeaderboardChart, dnsHealthChart, tlsLoginChart, statusCodeChart, headerCoverageChart, emailCoverageChart, techChart;
      let allTableRows = [];
      let currentPage = 1;
      let rowsPerPage = 20;
      let riskScores = {};
      let minRiskScore = Infinity;
      let maxRiskScore = -Infinity;
      let riskSortOrder = "desc";
      let riskEntries = [];

      // CSV Export Functions
      function downloadCSV(csv, filename) {
        const csvFile = new Blob([csv], { type: "text/csv" });
        const downloadLink = document.createElement("a");
        downloadLink.download = filename;
        downloadLink.href = window.URL.createObjectURL(csvFile);
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      }
      function exportAllTableRowsToCSV(filename) {
        const csv = [];
        const headerRow = document.querySelectorAll("#report-table thead tr")[0];
        const headers = [];
        headerRow.querySelectorAll("th").forEach(th => {
          headers.push('"' + th.innerText.trim().replace(/"/g, '""') + '"');
        });
        csv.push(headers.join(","));
        allTableRows.forEach(row => {
          const cols = row.querySelectorAll("td");
          const rowData = [];
          cols.forEach(td => {
            const text = getCellContentText(td);
            rowData.push('"' + text.replace(/"/g, '""') + '"');
          });
          csv.push(rowData.join(","));
        });
        downloadCSV(csv.join("\n"), filename);
      }
      document.getElementById("exportCsvButton").addEventListener("click", function() {
        exportAllTableRowsToCSV("report.csv");
      });

      function getCellContentText(cell) {
        if (!cell) return "";
        const wrapper = cell.querySelector(".cell-content");
        const source = wrapper || cell;
        return (source.innerText || "").trim();
      }

      function prepareRowCells(row) {
        const cells = Array.from(row.cells);
        cells.forEach((cell, index) => {
          if (index === 0) return;
          if (cell.dataset.clampPrepared === "true") return;
          if (cell.querySelector("img")) {
            cell.dataset.clampPrepared = "true";
            return;
          }
          const wrapper = document.createElement("div");
          wrapper.className = "cell-content";
          while (cell.firstChild) {
            wrapper.appendChild(cell.firstChild);
          }
          cell.appendChild(wrapper);
          const button = document.createElement("button");
          button.type = "button";
          button.className = "cell-expander";
          button.textContent = "View more";
          button.setAttribute("aria-expanded", "false");
          button.addEventListener("click", () => {
            const expanded = cell.classList.toggle("is-expanded");
            button.textContent = expanded ? "View less" : "View more";
            button.setAttribute("aria-expanded", String(expanded));
            updateSingleCellClamp(cell);
          });
          cell.appendChild(button);
          cell.dataset.clampPrepared = "true";
          updateSingleCellClamp(cell);
        });
      }

      function updateSingleCellClamp(cell) {
        const wrapper = cell.querySelector(".cell-content");
        const button = cell.querySelector(".cell-expander");
        if (!wrapper || !button) return;
        if (cell.classList.contains("is-expanded")) {
          cell.classList.add("is-clamped");
          button.style.display = "inline-flex";
          button.textContent = "View less";
          button.setAttribute("aria-expanded", "true");
          return;
        }
        const needsClamp = wrapper.scrollHeight > wrapper.clientHeight + 1;
        if (needsClamp) {
          cell.classList.add("is-clamped");
          button.style.display = "inline-flex";
          button.textContent = "View more";
          button.setAttribute("aria-expanded", "false");
        } else {
          cell.classList.remove("is-clamped", "is-expanded");
          button.style.display = "none";
          button.textContent = "View more";
          button.setAttribute("aria-expanded", "false");
        }
      }

      function updateClampStates(rows) {
        rows.forEach(row => {
          const cells = Array.from(row.cells);
          cells.forEach((cell, index) => {
            if (index === 0) return;
            if (cell.dataset.clampPrepared === "true") {
              updateSingleCellClamp(cell);
            }
          });
        });
      }

      // Theme-aware rendering relies on the active CSS custom properties.

      // Utility function
      function formatCell(arr) {
        return (arr && arr.length) ? arr.join("<br>") : "N/A";
      }

      // Compute risk score
      function computePriority({
        purpose, url, loginFound, statusCode, sslVersion, certExpiry,
        sts, xfo, csp, xss, rp, pp, openPortsCount, dbPortsCount, managementPortsCount, techCount, linkCount
      }) {

        let score = 0;
        const reasons = [];
        if (purpose && purpose.toLowerCase().includes("employee")) {
          score += 1;
          reasons.push("+1 (Potential employee-intended domain found)");
        }
        if (url && url !== "N/A") {
          score += 1;
          reasons.push("+1 (Domain has live application)");
        }
        if (loginFound === "Yes") {
          score += 1;
          reasons.push("+1 (Login interface found on application)");
        }
        if (statusCode === 200) {
          score += 1;
          reasons.push("+1 (Application has 200 status code)");
        }
        if (sslVersion) {
          const cleanVersion = sslVersion.replace(/\s+/g, '');
          if (/^TLSv(1\.2|1\.3)$/i.test(cleanVersion)) {
            reasons.push("+0 (Version of TLS is latest)");
          } else if (/^TLSv(1\.0|1\.1)$/i.test(cleanVersion)) {
            score += 2;
            reasons.push("+1 (TLSv1.0 or TLSv1.1)");
          } else if (/^SSLv(1\.0|2\.0|3\.0)$/i.test(cleanVersion)) {
            score += 5;
            reasons.push("+5 (SSLv1/2/3)");
          }
        } else {
          score += 1;
          reasons.push("+1 (no sslVersion reported)");
        }
        if (certExpiry && certExpiry !== "N/A") {
          const expiryDate = new Date(certExpiry);
          const now = new Date();
          const diffDays = (expiryDate - now) / (1000 * 60 * 60 * 24);
          if (!isNaN(diffDays)) {
            if (diffDays < 0) {
              score += 20;
              reasons.push("+20 (certificate expired)");
            } else if (diffDays <= 7) {
              score += 10;
              reasons.push("+10 (cert expires in ≤7 days)");
            } else if (diffDays <= 14) {
              score += 5;
              reasons.push("+5 (cert expires in ≤14 days)");
            } else if (diffDays <= 30) {
              score += 2;
              reasons.push("+2 (cert expires in ≤30 days)");
            }
          }
        }
        function missingHeader(val) {
          return !val || val.trim() === "" || val.trim().toLowerCase() === "false";
        }
        if (missingHeader(sts)) { score += 1; reasons.push("+1 (Missing HSTS)"); }
        if (missingHeader(xfo)) { score += 1; reasons.push("+1 (Missing X-Frame-Options)"); }
        if (missingHeader(csp)) { score += 1; reasons.push("+1 (missing CSP)"); }
        if (missingHeader(xss)) { score += 1; reasons.push("+1 (Missing X-XSS-Protection)"); }
        if (missingHeader(rp)) { score += 1; reasons.push("+1 (Missing Referrer-Policy)"); }
        if (missingHeader(pp)) { score += 1; reasons.push("+1 (Missing Permissions-Policy)"); }
        if (openPortsCount && Number.isFinite(openPortsCount)) {
          score += openPortsCount;
          reasons.push(`+${openPortsCount} (Each Open ports)`);
        }
        if (dbPortsCount && Number.isFinite(dbPortsCount)) {
          score += dbPortsCount;
          reasons.push(`+${dbPortsCount} (Database ports)`);
        }
        if (managementPortsCount && Number.isFinite(managementPortsCount)) {
          score += managementPortsCount;
          reasons.push(`+${managementPortsCount} (Management ports)`);
        }
        if (techCount && Number.isFinite(techCount)) {
          score += techCount;
          reasons.push(`+${techCount} (Tech stack count)`);
        }
        if (linkCount && Number.isFinite(linkCount) && linkCount > 0) {
          score += linkCount;
          reasons.push(`+${linkCount} (Crawled links discovered)`);
        }
        return { score, debug: reasons };
      }

      function getDynamicColor(score, minScore, maxScore) {
        if (!Number.isFinite(score)) return "rgb(59, 130, 246)";
        if (maxScore === minScore) return "rgb(59, 130, 246)";
        const fraction = Math.max(0, Math.min(1, (score - minScore) / (maxScore - minScore)));
        const start = { r: 46, g: 204, b: 113 };
        const mid = { r: 249, g: 115, b: 22 };
        const end   = { r: 239, g: 68, b: 68 };
        const pivot = 0.6;
        let from, to, localFraction;
        if (fraction <= pivot) {
          from = start;
          to = mid;
          localFraction = fraction / pivot;
        } else {
          from = mid;
          to = end;
          localFraction = (fraction - pivot) / (1 - pivot);
        }
        const r = Math.round(from.r + localFraction * (to.r - from.r));
        const g = Math.round(from.g + localFraction * (to.g - from.g));
        const b = Math.round(from.b + localFraction * (to.b - from.b));
        return `rgb(${r}, ${g}, ${b})`;
      }

      const ESCAPE_HTML_REGEX = /[&<>"']/g;
      const ESCAPE_HTML_MAP = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
      function escapeHtml(value) {
        if (value === undefined || value === null) return "";
        return String(value).replace(ESCAPE_HTML_REGEX, ch => ESCAPE_HTML_MAP[ch] || ch);
      }

      const FOOTPRINT_BUCKETS = [
        { max: 10, label: "Minimal" },
        { max: 50, label: "Lean" },
        { max: 150, label: "Growing" },
        { max: 400, label: "Large" },
        { max: Infinity, label: "Expansive" }
      ];

      function formatNumber(value) {
        const num = Number(value);
        if (!Number.isFinite(num)) return "0";
        return num.toLocaleString();
      }

      function pluralize(value, singular, plural) {
        return `${formatNumber(value)} ${value === 1 ? singular : (plural || `${singular}s`)}`;
      }

      function describeFootprint(pipeline) {
        const discovered = Number(pipeline?.discovered) || 0;
        const endpoints = Number(pipeline?.endpoints) || 0;
        const bucket = FOOTPRINT_BUCKETS.find(entry => discovered <= entry.max) || FOOTPRINT_BUCKETS[FOOTPRINT_BUCKETS.length - 1];
        const descriptorParts = [];
        if (discovered > 0) descriptorParts.push(pluralize(discovered, "domain"));
        if (endpoints > 0) descriptorParts.push(pluralize(endpoints, "endpoint"));
        if (!descriptorParts.length) descriptorParts.push("no observable assets");
        return {
          label: bucket.label,
          descriptor: descriptorParts.join(", ")
        };
      }

      function assessRiskPosture(summary) {
        if (!summary) {
          return { posture: "Low", reason: "" };
        }
        const reasons = [];
        let severity = 0;

        const riskScore = Number(summary.topRiskScore) || 0;
        if (riskScore >= 60) {
          severity += 4;
          reasons.push("top endpoints scoring 60+ risk");
        } else if (riskScore >= 40) {
          severity += 3;
          reasons.push("elevated endpoint risk scores");
        } else if (riskScore >= 25) {
          severity += 2;
          reasons.push("moderate endpoint risk");
        }

        const httpLogins = Number(summary?.httpLogin?.count) || 0;
        if (httpLogins > 0) {
          severity += httpLogins >= 5 ? 3 : 2;
          reasons.push(`${httpLogins} HTTP login surface${httpLogins === 1 ? "" : "s"}`);
        }

        const managementPorts = Number(summary.managementPortCount) || 0;
        if (managementPorts > 0) {
          severity += managementPorts > 5 ? 3 : 2;
          reasons.push(`${managementPorts} administrative service${managementPorts === 1 ? "" : "s"} exposed externally`);
        }

        const databasePorts = Number(summary.databasePortCount) || 0;
        if (databasePorts > 0) {
          severity += databasePorts > 2 ? 3 : 2;
          reasons.push(`${databasePorts} internet-facing database port${databasePorts === 1 ? "" : "s"}`);
        }

        const openPorts = Number(summary.totalOpenPorts) || 0;
        if (openPorts > 20) {
          severity += 2;
          reasons.push("high volume of open services");
        } else if (openPorts > 0) {
          severity += 1;
          reasons.push("multiple open services detected");
        }

        const missingDmarc = Number(summary.missingDmarc) || 0;
        if (missingDmarc > 0) {
          severity += missingDmarc > 3 ? 2 : 1;
          reasons.push(`email auth gaps on ${missingDmarc} domain${missingDmarc === 1 ? "" : "s"}`);
        }

        const dnsCoverage = Number(summary.dnsCoverage) || 0;
        if (dnsCoverage > 0 && dnsCoverage < 50) {
          severity += 1;
          reasons.push("large portion of discovered domains non-resolving");
        }

        const totalLoginSurfaces = Number(summary.totalLoginSurfaces) || 0;
        if (httpLogins === 0 && totalLoginSurfaces > 0) severity = Math.max(0, severity - 1);

        const emailTotal = Number(summary?.emailCoverage?.total) || 0;
        if (emailTotal && summary.emailCoverage?.dmarcCovered === emailTotal) severity = Math.max(0, severity - 1);

        if (openPorts === 0) severity = Math.max(0, severity - 1);

        let posture = "Low";
        if (severity >= 7) posture = "Critical";
        else if (severity >= 4) posture = "Elevated";
        else if (severity >= 2) posture = "Watch";

        return {
          posture,
          reason: reasons.slice(0, 2).join("; ")
        };
      }

      function buildKeyDrivers(summary, topRisk) {
        const candidates = [];
        const pushDriver = (condition, text, weight) => {
          if (!condition || !text) return;
          candidates.push({ text, weight });
        };

        const riskLabel = topRisk?.label || summary?.topRiskLabel;
        const riskScore = Number(topRisk?.score ?? summary?.topRiskScore);
        if (riskLabel) {
          const suffix = Number.isFinite(riskScore) && riskScore > 0 ? ` (score ${riskScore})` : "";
          pushDriver(true, `Risk hotspot: ${riskLabel}${suffix}`, 80);
        }

        const httpLogins = Number(summary?.httpLogin?.count) || 0;
        pushDriver(httpLogins > 0, `${httpLogins} login flow${httpLogins === 1 ? "" : "s"} still run over HTTP`, 90);
        const totalLoginSurfaces = Number(summary?.totalLoginSurfaces) || 0;
        if (httpLogins === 0 && totalLoginSurfaces > 0) {
          pushDriver(true, "All login surfaces enforce HTTPS", 30);
        }

        const managementPorts = Number(summary?.managementPortCount) || 0;
        pushDriver(managementPorts > 0, `${managementPorts} administrative service${managementPorts === 1 ? "" : "s"} exposed externally`, 85);

        const databasePorts = Number(summary?.databasePortCount) || 0;
        pushDriver(databasePorts > 0, `${databasePorts} database port${databasePorts === 1 ? "" : "s"} reachable from the internet`, 75);

        const openPorts = Number(summary?.totalOpenPorts) || 0;
        pushDriver(openPorts > 0 && managementPorts + databasePorts === 0, `${openPorts} miscellaneous services exposed`, 55);
        pushDriver(openPorts === 0, "No unexpected services detected beyond core web stack", 25);

        const nxdomain = Number(summary?.nxdomainCount) || 0;
        pushDriver(nxdomain > 0, `${nxdomain} dormant NXDOMAIN host${nxdomain === 1 ? "" : "s"} still referenced`, 45);

        const emailTotal = Number(summary?.emailCoverage?.total) || 0;
        const dmarcCovered = Number(summary?.emailCoverage?.dmarcCovered) || 0;
        const missingDmarc = Math.max(emailTotal - dmarcCovered, 0);
        if (missingDmarc > 0) {
          pushDriver(true, `Email auth missing on ${missingDmarc} of ${emailTotal} domains`, 70);
        } else if (emailTotal) {
          pushDriver(true, `DMARC enforced across all ${emailTotal} monitored domains`, 35);
        }

        const dnsCoverage = Number(summary?.dnsCoverage) || 0;
        const discovered = Number(summary?.pipeline?.discovered) || 0;
        if (discovered > 0) {
          pushDriver(dnsCoverage < 60, `Only ${dnsCoverage}% of discovered domains still resolve`, 40);
          pushDriver(dnsCoverage >= 90, `${dnsCoverage}% of discovered domains resolve cleanly`, 25);
        }

        const employeeAssets = Number(summary?.employeeAssetCount) || 0;
        pushDriver(employeeAssets > 0, `${employeeAssets} employee-facing asset${employeeAssets === 1 ? "" : "s"} surfaced`, 35);

        const katanaTotal = Number(summary?.katanaTotal) || 0;
        pushDriver(katanaTotal > 1500, `${katanaTotal.toLocaleString()} crawlable URLs uncovered`, 30);

        const headerBaseline = Number(summary?.headerBaseline) || 0;
        if (headerBaseline > 0 && summary?.headerCoverage) {
          const hstsPresent = summary.headerCoverage["HSTS"]?.present ?? summary.headerCoverage["Strict-Transport-Security"]?.present;
          if (Number(hstsPresent) === headerBaseline) {
            pushDriver(true, "HSTS present across observed domains", 20);
          }
        }

        const seen = new Set();
        return candidates
          .sort((a, b) => b.weight - a.weight)
          .map(item => item.text)
          .filter(text => {
            if (!text || seen.has(text)) return false;
            seen.add(text);
            return true;
          })
          .slice(0, 3);
      }

      function buildNarrative(summary, posture, footprint) {
        if (!summary) return "";
        const sentences = [];
        const footprintSnippet = footprint?.descriptor
          ? `${footprint.label} footprint (${footprint.descriptor})`
          : `${footprint?.label || "Minimal"} footprint`;
        sentences.push(`${footprintSnippet.charAt(0).toUpperCase()}${footprintSnippet.slice(1)}.`);

        if (posture?.posture) {
          const reason = posture.reason ? ` because ${posture.reason}` : "";
          sentences.push(`Overall posture is ${posture.posture}${reason}.`);
        }

        const positives = [];
        const httpLogins = Number(summary?.httpLogin?.count) || 0;
        const totalLogins = Number(summary?.totalLoginSurfaces) || 0;
        if (httpLogins === 0 && totalLogins > 0) positives.push("All login flows enforce HTTPS.");

        const emailTotal = Number(summary?.emailCoverage?.total) || 0;
        if (emailTotal && summary.emailCoverage?.dmarcCovered === emailTotal) positives.push("DMARC is enforced across every monitored domain.");

        if (Number(summary?.totalOpenPorts) === 0) positives.push("No unexpected services were detected beyond the primary web stack.");

        if (Number(summary?.katanaTotal) && Number(summary.katanaTotal) <= 200) {
          positives.push(`${formatNumber(summary.katanaTotal)} crawlable URLs surfaced, manageable for manual review.`);
        }

        if (positives.length) sentences.push(positives.slice(0, 2).join(" "));

        return sentences.join(" ").replace(/\s+/g, " ").trim();
      }

      function generateExecutiveSummary({ summarySignals, actions, topRisk }) {
        const footprint = describeFootprint(summarySignals?.pipeline || {});
        const posture = assessRiskPosture(summarySignals || {});
        const keyDrivers = buildKeyDrivers(summarySignals || {}, topRisk);
        const narrative = buildNarrative(summarySignals || {}, posture, footprint);

        const actionList = Array.isArray(actions) && actions.length
          ? actions.slice(0, 3)
          : ["Maintain current controls and monitor upcoming scans for emerging trends."];

        return {
          heading: `Executive Summary - ${posture.posture || "Low"}`,
          postureLabel: "Overall posture",
          postureValue: posture.posture || "Low",
          footprintText: footprint.descriptor
            ? `${footprint.label} footprint - ${footprint.descriptor}`
            : `${footprint.label} footprint`,
          narrative,
          keyDrivers,
          actionList
        };
      }

      function buildScoreboard(metrics) {
        const sb = document.getElementById("scoreboard");
        if (!sb || !metrics) return;

        const {
          pipeline,
          topRisk,
          actions,
          exposure,
          authentication,
          controls,
          infrastructure,
          metadata,
          summary
        } = metrics;
        const summaryData = generateExecutiveSummary({
          summarySignals: summary,
          actions,
          topRisk
        });
        const contextMap = {
          "Discovered Subdomains": "Total internet-facing domains discovered this run.",
          "DNS Resolvable": "Shows which domains still resolve publicly and are reachable.",
          "Active Web Hosts": "Live hosts serving HTTP/S content attackers can reach.",
          "NXDOMAIN Findings": "Dormant names still owned but no longer resolving.",
          "Login Interfaces": "Applications presenting an authentication flow to users.",
          "HTTP Login Pages": "Plaintext logins that can be intercepted or modified.",
          "HTTPS Login Pages": "Login flows already protected by TLS.",
          "Employee-Facing Assets": "Assets intended for staff that warrant extra scrutiny.",
          "SPF Coverage": "Domains publishing SPF to curb sender spoofing.",
          "DMARC Coverage": "Domains enforcing DMARC for phishing resilience.",
          "DKIM Coverage": "Domains signing outbound mail with DKIM.",
          "DNSSEC Enabled": "Domains validated with DNSSEC against tampering.",
          "Open Services": "Externally reachable TCP services on observed hosts.",
          "Management Ports": "Administrative services such as SSH or RDP exposed.",
          "Database Ports": "Database engines reachable directly from the internet.",
          "Shared Host Exposure": "Hostnames co-hosted on the same origin/IP."
        };

        const renderScoreCard = ({ label, value, meta, tone, context }) => {
          const toneClass = tone ? ` score-card--${tone}` : "";
          const normalizedValue = (typeof value === "number" && Number.isFinite(value))
            ? value.toLocaleString()
            : escapeHtml(value);
          const safeMeta = meta ? escapeHtml(meta) : "";
          const contextText = context || contextMap[label];
          const contextMarkup = contextText
            ? `<p class="score-card__context">${escapeHtml(contextText)}</p>`
            : "";
          return `
            <article class="score-card${toneClass}">
              <p class="score-card__label">${escapeHtml(label)}</p>
              <h2>${normalizedValue}</h2>
              ${safeMeta ? `<p class="score-card__meta">${safeMeta}</p>` : ""}
              ${contextMarkup}
            </article>
          `;
        };

        const renderSection = (title, items) => {
          if (!Array.isArray(items) || items.length === 0) return "";
          return `
            <div class="scoreboard__section">
              <h3 class="scoreboard__section-title">${escapeHtml(title)}</h3>
              <div class="scoreboard__grid scoreboard__grid--kpis">
                ${items.map(renderScoreCard).join("")}
              </div>
            </div>
          `;
        };

        const postureLabel = summaryData.postureLabel || "Overall posture";
        const postureValue = summaryData.postureValue || ((typeof topRisk?.score === "number" && Number.isFinite(topRisk.score)) ? topRisk.score.toLocaleString() : "Low");
        const defaultFootprint = pipeline
          ? `${pipeline.discovered.toLocaleString()} discovered -> ${pipeline.resolvable.toLocaleString()} resolvable -> ${pipeline.webHosts.toLocaleString()} web hosts`
          : "No footprint data available";
        const footprintText = summaryData.footprintText || defaultFootprint;
        const keyDrivers = Array.isArray(summaryData.keyDrivers) ? summaryData.keyDrivers : [];
        const riskContext = keyDrivers.length
          ? `<p class="summary-card__meta">Key drivers: ${escapeHtml(keyDrivers.join(" | "))}</p>`
          : "";
        const narrativeCopy = summaryData.narrative || defaultFootprint;
        const actionsList = (Array.isArray(summaryData.actionList) && summaryData.actionList.length
          ? summaryData.actionList
          : (Array.isArray(actions) && actions.length ? actions : ["Maintain current controls and monitor upcoming scans for emerging trends."]))
          .slice(0, 3);
        const summaryActions = actionsList
          .map(item => `<li>${escapeHtml(item)}</li>`)
          .join("");
        const timestampLabel = metadata?.timestampLabel ? escapeHtml(metadata.timestampLabel) : "Scan time unavailable";
        const summaryMeta = metadata?.meta ? `<p class="summary-card__meta">${escapeHtml(metadata.meta)}</p>` : "";

        sb.innerHTML = `
          <article class="summary-card">
            <div class="summary-card__header">
              <h2>${escapeHtml(summaryData.heading || "Executive Summary")}</h2>
              <span class="summary-card__timestamp">${timestampLabel}</span>
            </div>
            <div class="summary-card__headline">
              <span class="summary-card__risk-label">${escapeHtml(postureLabel)}</span>
              <span class="summary-card__risk-score">${escapeHtml(postureValue)}</span>
              <span class="summary-card__risk-asset">${escapeHtml(footprintText)}</span>
            </div>
            ${riskContext}
            ${narrativeCopy ? `<p class="summary-card__pipeline">${escapeHtml(narrativeCopy)}</p>` : ""}
            <div class="summary-card__actions">
              <span>Immediate actions</span>
              <ul>${summaryActions}</ul>
            </div>
            ${summaryMeta}
          </article>
          ${renderSection("Exposure", exposure)}
          ${renderSection("Authentication", authentication)}
          ${renderSection("Controls", controls)}
          ${renderSection("Infrastructure", infrastructure)}
        `;
      }

      function coerceTimestamp(value) {
        if (!value) return null;
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      }

      function deriveScanTimestamp(datasets) {
        const timestamps = [];
        datasets.forEach(data => {
          if (!Array.isArray(data)) return;
          data.forEach(entry => {
            if (!entry) return;
            const ts = entry.timestamp || entry.Timestamp || entry.time || entry.scanned_at;
            const parsed = coerceTimestamp(ts);
            if (parsed) {
              timestamps.push(parsed);
            }
          });
        });
        if (!timestamps.length) return null;
        return new Date(Math.max(...timestamps.map(date => date.getTime())));
      }

      function formatTimestampUTC(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return null;
        try {
          return date.toLocaleString("en-US", {
            timeZone: "UTC",
            year: "numeric",
            month: "short",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false
          }) + " UTC";
        } catch {
          return null;
        }
      }

      function categorizePort(port) {
        if (WEB_PORTS.has(port)) return "Web";
        if (EMAIL_TRANSPORT_PORTS.has(port)) return "Email Transport";
        if (EMAIL_ACCESS_PORTS.has(port)) return "Email Access";
        if (DATABASE_PORTS.has(port)) return "Database";
        if (MANAGEMENT_PORTS.has(port)) return "Management";
        if (DNS_PORTS.has(port)) return "DNS";
        if (FTP_PORTS.has(port)) return "FTP";
        return "Other";
      }

      function prepareNaabuInsights(naabuData) {
        const naabuMap = {};
        const categoryCounts = {
          "Web": 0,
          "Email Transport": 0,
          "Email Access": 0,
          "Database": 0,
          "Management": 0,
          "DNS": 0,
          "FTP": 0,
          "Other": 0
        };
        naabuData.forEach(entry => {
          const host = entry.host;
          const port = Number(entry.port);
          const service = entry.service || "";
          if (!naabuMap[host]) naabuMap[host] = [];
          naabuMap[host].push({ port, service });

          const category = categorizePort(port);
          categoryCounts[category] = (categoryCounts[category] || 0) + 1;
        });

        return { naabuMap, categoryCounts };
      }

      function describeEndpoint(entry) {
        if (!entry) return "";
        const raw = typeof entry === "string" ? entry : entry.url || entry.domain || "";
        if (!raw) return "";
        try {
          const parsed = new URL(raw.startsWith("http") ? raw : `http://${raw}`);
          const protocol = parsed.protocol.replace(":", "").toUpperCase();
          const port = parsed.port || (parsed.protocol === "https:" ? "443" : parsed.protocol === "http:" ? "80" : "");
          const host = parsed.hostname || raw;
          return port ? `${host}:${port} ${protocol}` : `${host} ${protocol}`;
        } catch {
          return raw;
        }
      }


// Visualisation builder for charts
function buildInsightsCharts({
  pipeline,
  riskLeaderboard,
  dnsStats,
  exposureMatrix,
  headerCoverage,
  emailCoverage,
  statusBreakdown,
  topTechnologies
}) {
  const tokens = getDesignTokens();
  const chartText = getChartTextColor(tokens);
  const createTicks = () => ({
    color: chartText,
    font: { family: tokens.fontFamily, weight: "500" }
  });
  const createGrid = (display = true) => ({
    color: tokens.grid,
    drawBorder: false,
    borderDash: [4, 4],
    display
  });
  const tooltipTheme = getTooltipTheme(tokens);

  const replaceWithMessage = (canvas, message) => {
    if (!canvas) return;
    const parent = canvas.parentElement;
    if (parent) {
      parent.innerHTML = `<p>${escapeHtml(message)}</p>`;
    }
  };

  (function buildFunnel() {
    const canvas = document.getElementById("funnelChart");
    if (!canvas) return;
    const labels = ["Discovered", "Resolvable", "Web Hosts"];
    const data = [
      Number(pipeline?.discovered) || 0,
      Number(pipeline?.resolvable) || 0,
      Number(pipeline?.webHosts) || 0
    ];
    if (!data.some(value => value > 0)) {
      replaceWithMessage(canvas, "No asset discovery data available.");
      funnelChart = undefined;
      return;
    }
    if (funnelChart) funnelChart.destroy();
    funnelChart = new Chart(canvas, {
      type: "bar",
      data: {
        labels,
        datasets: [{
          label: "Assets",
          data,
          backgroundColor: ["#3b82f6", "#8b5cf6", "#14b8a6"],
          borderRadius: 12,
          maxBarThickness: 48
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: tooltipTheme
        },
        scales: {
          x: { ticks: createTicks(), grid: createGrid(false) },
          y: { beginAtZero: true, ticks: createTicks(), grid: createGrid() }
        }
      }
    });
  })();

  (function buildRiskLeaderboard() {
    const canvas = document.getElementById("riskLeaderboardChart");
    if (!canvas) return;
    const topEntries = Array.isArray(riskLeaderboard) ? riskLeaderboard.slice(0, 6) : [];
    if (!topEntries.length) {
      replaceWithMessage(canvas, "Risk scoring unavailable.");
      riskLeaderboardChart = undefined;
      return;
    }
    const labels = topEntries.map(entry => describeEndpoint(entry));
    const data = topEntries.map(entry => Number(entry.score) || 0);
    if (riskLeaderboardChart) riskLeaderboardChart.destroy();
    riskLeaderboardChart = new Chart(canvas, {
      type: "bar",
      data: {
        labels,
        datasets: [{
          label: "Score",
          data,
          backgroundColor: "#ef4444",
          borderRadius: 10,
          maxBarThickness: 40
        }]
      },
      options: {
        indexAxis: "y",
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: tooltipTheme
        },
        scales: {
          x: { beginAtZero: true, ticks: createTicks(), grid: createGrid() },
          y: { ticks: createTicks(), grid: createGrid(false) }
        }
      }
    });
  })();

  (function buildDnsHealth() {
    const canvas = document.getElementById("dnsHealthChart");
    if (!canvas) return;
    const values = [
      Number(dnsStats?.resolvable) || 0,
      Number(dnsStats?.nxdomain) || 0,
      Number(dnsStats?.other) || 0
    ];
    if (!values.some(value => value > 0)) {
      replaceWithMessage(canvas, "No DNS health data available.");
      dnsHealthChart = undefined;
      return;
    }
    if (dnsHealthChart) dnsHealthChart.destroy();
    dnsHealthChart = new Chart(canvas, {
      type: "doughnut",
      data: {
        labels: ["Resolvable", "NXDOMAIN", "Other"],
        datasets: [{
          data: values,
          backgroundColor: ["#22c55e", "#ef4444", "#f97316"],
          borderWidth: 0
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: {
            position: "bottom",
            labels: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } }
          },
          tooltip: tooltipTheme
        }
      }
    });
  })();

  (function buildTlsExposure() {
    const canvas = document.getElementById("tlsLoginChart");
    if (!canvas) return;
    const httpEndpoints = Number(exposureMatrix?.endpoints?.http) || 0;
    const httpsEndpoints = Number(exposureMatrix?.endpoints?.https) || 0;
    const httpLogins = Number(exposureMatrix?.logins?.http) || 0;
    const httpsLogins = Number(exposureMatrix?.logins?.https) || 0;
    if (!(httpEndpoints || httpsEndpoints || httpLogins || httpsLogins)) {
      replaceWithMessage(canvas, "No HTTP service coverage data available.");
      tlsLoginChart = undefined;
      return;
    }
    if (tlsLoginChart) tlsLoginChart.destroy();
    tlsLoginChart = new Chart(canvas, {
      type: "bar",
      data: {
        labels: ["Endpoints", "Login Interfaces"],
        datasets: [
          {
            label: "HTTP",
            data: [httpEndpoints, httpLogins],
            backgroundColor: "#ef4444",
            borderRadius: 8,
            maxBarThickness: 42
          },
          {
            label: "HTTPS",
            data: [httpsEndpoints, httpsLogins],
            backgroundColor: "#22c55e",
            borderRadius: 8,
            maxBarThickness: 42
          }
        ]
      },
      options: {
        indexAxis: "y",
        responsive: true,
        plugins: {
          legend: {
            position: "bottom",
            labels: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } }
          },
          tooltip: tooltipTheme
        },
        scales: {
          x: { stacked: true, beginAtZero: true, ticks: createTicks(), grid: createGrid() },
          y: { stacked: true, ticks: createTicks(), grid: createGrid(false) }
        }
      }
    });
  })();

  (function buildStatusCodeChart() {
    const canvas = document.getElementById("statusCodeChart");
    if (!canvas) return;
    const entries = Array.isArray(statusBreakdown) ? statusBreakdown : [];
    if (!entries.some(([, count]) => count > 0)) {
      replaceWithMessage(canvas, "No HTTP status data available.");
      statusCodeChart = undefined;
      return;
    }
    const labels = entries.map(([code]) => code);
    const data = entries.map(([, count]) => count);
    if (statusCodeChart) statusCodeChart.destroy();
    const palette = ["#22c55e", "#3b82f6", "#f97316", "#facc15", "#ef4444", "#a855f7", "#0ea5e9"];
    statusCodeChart = new Chart(canvas, {
      type: "bar",
      data: {
        labels,
        datasets: [{
          label: "Responses",
          data,
          backgroundColor: labels.map((_, idx) => palette[idx % palette.length]),
          borderRadius: 10,
          maxBarThickness: 40
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: tooltipTheme
        },
        scales: {
          x: { ticks: createTicks(), grid: createGrid(false) },
          y: { beginAtZero: true, ticks: createTicks(), grid: createGrid() }
        }
      }
    });
  })();

  (function buildTopTechChart() {
    const canvas = document.getElementById("techChart");
    if (!canvas) return;
    const entries = Array.isArray(topTechnologies) ? topTechnologies : [];
    if (!entries.some(([, count]) => count > 0)) {
      replaceWithMessage(canvas, "No technology fingerprints collected.");
      techChart = undefined;
      return;
    }
    const labels = entries.map(([name]) => name);
    const data = entries.map(([, count]) => count);
    if (techChart) techChart.destroy();
    techChart = new Chart(canvas, {
      type: "bar",
      data: {
        labels,
        datasets: [{
          label: "Occurrences",
          data,
          backgroundColor: "#3b82f6",
          borderRadius: 10,
          maxBarThickness: 40
        }]
      },
      options: {
        indexAxis: "y",
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: tooltipTheme
        },
        scales: {
          x: { beginAtZero: true, ticks: createTicks(), grid: createGrid() },
          y: { ticks: createTicks(), grid: createGrid(false) }
        }
      }
    });
  })();


  (function buildHeaderCoverage() {
    const canvas = document.getElementById("headerCoverageChart");
    if (!canvas) return;
    const labels = Object.keys(headerCoverage || {});
    if (!labels.length) {
      replaceWithMessage(canvas, "No security header data collected.");
      headerCoverageChart = undefined;
      return;
    }
    const present = labels.map(label => Number(headerCoverage[label]?.present) || 0);
    const missing = labels.map(label => Number(headerCoverage[label]?.missing) || 0);
    if (headerCoverageChart) headerCoverageChart.destroy();
    headerCoverageChart = new Chart(canvas, {
      type: "bar",
      data: {
        labels,
        datasets: [
          {
            label: "Present",
            data: present,
            backgroundColor: "#22c55e",
            borderRadius: 8,
            maxBarThickness: 36
          },
          {
            label: "Missing",
            data: missing,
            backgroundColor: "#ef4444",
            borderRadius: 8,
            maxBarThickness: 36
          }
        ]
      },
      options: {
        responsive: true,
        plugins: {
          legend: {
            position: "bottom",
            labels: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } }
          },
          tooltip: tooltipTheme
        },
        scales: {
          x: { stacked: true, ticks: createTicks(), grid: createGrid(false) },
          y: { stacked: true, beginAtZero: true, ticks: createTicks(), grid: createGrid() }
        }
      }
    });
  })();

  (function buildEmailCoverage() {
    const canvas = document.getElementById("emailCoverageChart");
    if (!canvas) return;
    const labels = Object.keys(emailCoverage || {});
    if (!labels.length) {
      replaceWithMessage(canvas, "No email security data collected.");
      emailCoverageChart = undefined;
      return;
    }
    const configured = labels.map(label => Number(emailCoverage[label]?.configured) || 0);
    const missing = labels.map(label => Number(emailCoverage[label]?.missing) || 0);
    if (emailCoverageChart) emailCoverageChart.destroy();
    emailCoverageChart = new Chart(canvas, {
      type: "bar",
      data: {
        labels,
        datasets: [
          {
            label: "Configured",
            data: configured,
            backgroundColor: "#3b82f6",
            borderRadius: 8,
            maxBarThickness: 36
          },
          {
            label: "Missing",
            data: missing,
            backgroundColor: "#f97316",
            borderRadius: 8,
            maxBarThickness: 36
          }
        ]
      },
      options: {
        responsive: true,
        plugins: {
          legend: {
            position: "bottom",
            labels: { color: chartText, font: { family: tokens.fontFamily, weight: "500" } }
          },
          tooltip: tooltipTheme
        },
        scales: {
          x: { stacked: true, ticks: createTicks(), grid: createGrid(false) },
          y: { stacked: true, beginAtZero: true, ticks: createTicks(), grid: createGrid() }
        }
      }
    });
  })();

  ;
}

      // Global array to store table rows.
      let rowDataStore = [];

      // Build table rows
      function buildTableRows(combinedData, secMapDomain, secMapUrl, loginMap, apiMap, colleagueMap) {
        allTableRows = [];
        rowDataStore = [];
        riskEntries = [];
        Object.keys(combinedData).forEach(domain => {
          const { dns, http } = combinedData[domain];
          const dnsResolvers = dns && dns.resolver ? dns.resolver : [];
          const dnsA = dns && dns.a ? dns.a : [];
          const dnsStatus = dns ? dns.status_code : "N/A";
          const domainSec = secMapDomain[domain] || {};
          const spf = domainSec["SPF Record"] || "N/A";
          const dkim = domainSec["DKIM Record"] || "N/A";
          const dmarc = domainSec["DMARC Record"] || "N/A";
          const dnssec = domainSec["DNSSEC Status"] || "N/A";
          const nsRecords = (domainSec["NS Records"] || "N/A").replace(/\n/g, " ");
          const mxRecords = (domainSec["MX Records"] || "N/A").replace(/\n/g, " ");
          const ptrRecords = domainSec["PTR Record"] || "N/A";
          if (http && http.length) {
            http.forEach(h => {
              // Compute port and screenshot key for this record
              const port = h.port ? h.port : (h.url && h.url.startsWith("https") ? 443 : 80);
              const screenshotKey = domain + "_" + port;
              let screenshotHTML = "No screenshot";
              // Use the global screenshotMap defined earlier

              if (screenshotMap[screenshotKey]) {
                screenshotHTML = `
                  <span style="display:none;">has screenshot</span>
                  <img
                    src="${screenshotMap[screenshotKey]}"
                    class="thumbnail"
                    onclick="openModal('${screenshotMap[screenshotKey]}')"
                    alt="screenshot"
                  />
                `;
              } else {
                screenshotHTML = `
                  <span style="display:none;">no screenshot</span>
                  No screenshot
                `;
              }

              const urlSec = secMapUrl[h.url] || domainSec;
              const sslVersion = urlSec["SSL/TLS Version"] || "N/A";
              const certExpiry = urlSec["Cert Expiry Date"] || "N/A";
              const sslIssuer = urlSec["SSL/TLS Issuer"] || "N/A";
              const stsFlag = (urlSec["Strict-Transport-Security"] || "").trim();
              const xfoFlag = (urlSec["X-Frame-Options"] || "").trim();
              const cspFlag = (urlSec["Content-Security-Policy"] || "").trim();
              const xssFlag = (urlSec["X-XSS-Protection"] || "").trim();
              const rpFlag = (urlSec["Referrer-Policy"] || "").trim();
              const ppFlag = (urlSec["Permissions-Policy"] || "").trim();
              const techArr = Array.isArray(h.tech) ? h.tech : [];
              const sanitizedTech = techArr.map(item => item.replace(/\r?\n|\r/g, " ").trim());
              const techCount = sanitizedTech.length;
              const openPorts = (window.naabuMap && window.naabuMap[domain]) || [];
              const openPortsCount = openPorts.length;
              let dbPortsCount = 0;
              let managementPortsCount = 0;
              const categoryCounts = {};
              openPorts.forEach(portObj => {
                const numericPort = Number(portObj.port);
                const category = categorizePort(numericPort);
                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
                if (DATABASE_PORTS.has(numericPort)) dbPortsCount++;
                if (MANAGEMENT_PORTS.has(numericPort)) managementPortsCount++;
              });
              const sortedCategories = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1]);
              const chipTone = category => {
                if (category === "Management" || category === "Database") return "chip--danger";
                if (category.startsWith("Email")) return "chip--warning";
                if (category === "DNS") return "chip--info";
                return "";
              };
              const categoryChipsHtml = sortedCategories.map(([category, count]) => {
                const toneClass = chipTone(category);
                const countMarkup = count > 1 ? `<small>${count}</small>` : "";
                return `<span class="chip ${toneClass}">${escapeHtml(category)}${countMarkup}</span>`;
              }).join("");
              const openPortsDetails = openPorts.length
                ? openPorts.map(p => `${escapeHtml(String(p.port))} (${escapeHtml(p.service || "Unknown")})`).join("<br>")
                : "N/A";
              const chipsWrapper = categoryChipsHtml ? `<div class="chip-group">${categoryChipsHtml}</div>` : "";

              const linksForUrl = (window.linksMap && window.linksMap[h.url]) ? window.linksMap[h.url] : [];
              const linkCount = linksForUrl.length;
              const linksCellHTML = linkCount > 0
                ? `<a href="#" onclick="openLinksModal('${h.url}'); return false;">${linkCount}</a>`
                : "N/A";

              const { score, debug } = computePriority({
                purpose: colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended",
                url: h.url,
                loginFound: loginMap[h.url] || "N/A",
                statusCode: h.status_code,
                sslVersion,
                certExpiry,
                sts: stsFlag,
                xfo: xfoFlag,
                csp: cspFlag,
                xss: xssFlag,
                rp: rpFlag,
                pp: ppFlag,
                openPortsCount: openPortsCount,
                dbPortsCount: dbPortsCount,
                managementPortsCount: managementPortsCount,
                techCount,
                linkCount
              });
              if (score < minRiskScore) minRiskScore = score;
              if (score > maxRiskScore) maxRiskScore = score;
              riskScores[domain] = score;
              riskEntries.push({
                domain,
                url: h.url,
                score,
                reasons: Array.isArray(debug) ? [...debug] : [],
                loginFound: loginMap[h.url] === "Yes",
                scheme: h.scheme || ((h.url || "").startsWith("https") ? "https" : "http"),
                openPortsCount,
                dbPortsCount,
                managementPortsCount,
                statusCode: h.status_code
              });
              rowDataStore.push({ domain, prioScore: score });
              const row = document.createElement("tr");
              row.innerHTML = `
                <td><!-- risk score cell --></td>
                <td>${domain}</td>
                <td>${colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended"}</td>
                <td>${formatCell(dnsResolvers)}</td>
                <td>${formatCell(dnsA)}</td>
                <td>${nsRecords}</td>
                <td>${mxRecords}</td>
                <td>${ptrRecords}</td>
                <td>${dnsStatus}</td>
                <td>${h.cdn_name || "N/A"}</td>
                <td>${h.cdn_type || "N/A"}</td>
                <td>${h.port || "N/A"}</td>
                <td>${h.url || "N/A"}</td>
                <td>${screenshotHTML}</td>
                <td>${h.location || "N/A"}</td>
                <td>${h.title || "N/A"}</td>
                <td>${h.webserver || "N/A"}</td>
                <td>${loginMap[h.url] || "N/A"}</td>
                <td>${apiMap[domain] || "No"}</td>
                <td>${sanitizedTech.length ? sanitizedTech.join("<br>") : "N/A"}</td>
                <td>${(h.status_code !== undefined) ? h.status_code : "N/A"}</td>
                <td>${(h.content_length !== undefined) ? h.content_length : "N/A"}</td>
                <td>${(h.cdn !== undefined) ? h.cdn : "N/A"}</td>
                <td>${spf}</td>
                <td>${dkim}</td>
                <td>${dmarc}</td>
                <td>${dnssec}</td>
                <td>${sslVersion}</td>
                <td>${certExpiry}</td>
                <td>${sslIssuer}</td>
                <td>${stsFlag ? "True" : "False"}</td>
                <td>${xfoFlag ? "True" : "False"}</td>
                <td>${cspFlag ? "True" : "False"}</td>
                <td>${xssFlag ? "True" : "False"}</td>
                <td>${rpFlag ? "True" : "False"}</td>
                <td>${ppFlag ? "True" : "False"}</td>
                <td>${openPortsDetails}${chipsWrapper}</td>
                <td>${linksCellHTML}</td>
              `;
              const scoreCell = row.getElementsByTagName("td")[0];
              const reasonsText = Array.isArray(debug) ? debug.map(reason => String(reason || "")).join("\n") : "";
              scoreCell.innerHTML = `<span class="score-badge" title="${escapeHtml(reasonsText)}">${score}</span>`;
              scoreCell.title = reasonsText;
              const emailAuthMissing = [spf, dkim, dmarc].some(value => typeof value === "string" && value.toLowerCase().includes("no "));
              row.dataset.score = String(score);
              row.dataset.httpLogin = (loginMap[h.url] === "Yes" && (h.url || "").startsWith("http://")) ? "1" : "0";
              row.dataset.emailAuthMissing = emailAuthMissing ? "1" : "0";
              row.dataset.nxdomain = dnsStatus === "NXDOMAIN" ? "1" : "0";
              prepareRowCells(row);
              allTableRows.push(row);
            });
          }
          else {
            // If no HTTP data for domain, create a default row.
            const row = document.createElement("tr");
            row.innerHTML = `
              <td>N/A</td>
              <td>${domain}</td>
              <td>${colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended"}</td>
              <td>${formatCell(dnsResolvers)}</td>
              <td>${formatCell(dnsA)}</td>
              <td>${nsRecords}</td>
              <td>${mxRecords}</td>
              <td>${ptrRecords}</td>
              <td>${dnsStatus}</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>No screenshot</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>${spf}</td>
              <td>${dkim}</td>
              <td>${dmarc}</td>
              <td>${dnssec}</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>N/A</td>
            `;
            prepareRowCells(row);
            const emailAuthMissing = [spf, dkim, dmarc].some(value => typeof value === "string" && value.toLowerCase().includes("no "));
            row.dataset.score = "0";
            row.dataset.httpLogin = "0";
            row.dataset.emailAuthMissing = emailAuthMissing ? "1" : "0";
            row.dataset.nxdomain = dnsStatus === "NXDOMAIN" ? "1" : "0";
            allTableRows.push(row);
          }
        });
      }

      function finalizeColors() {
        allTableRows.forEach(row => {
          const scoreBadge = row.querySelector(".score-badge");
          if (!scoreBadge) return;
          const scoreValue = parseInt(scoreBadge.textContent, 10);
          if (!Number.isFinite(scoreValue)) return;
          const scoreCell = scoreBadge.closest("td");
          if (!scoreCell) return;
          const color = getDynamicColor(scoreValue, minRiskScore, maxRiskScore);
          scoreCell.style.backgroundColor = color;
          scoreCell.style.color = "#fff";
          scoreCell.style.fontWeight = "700";
          scoreCell.style.textAlign = "center";
          scoreCell.style.verticalAlign = "middle";
          scoreBadge.classList.remove("score-badge--critical", "score-badge--high", "score-badge--moderate", "score-badge--low");
          if (scoreValue >= 100) {
            scoreBadge.classList.add("score-badge--critical");
          } else if (scoreValue >= 60) {
            scoreBadge.classList.add("score-badge--high");
          } else if (scoreValue >= 30) {
            scoreBadge.classList.add("score-badge--moderate");
          } else {
            scoreBadge.classList.add("score-badge--low");
          }
          scoreBadge.style.background = "rgba(255, 255, 255, 0.18)";
          scoreBadge.style.color = "#fff";
        });
      }

      // Update filtering – note that we add a check for screenshot filter in column index 13.
      function getFilteredRows() {
        const query = document.getElementById("searchBox").value.toLowerCase();
        const filters = {
          priority: document.getElementById("priority-filter").value.toLowerCase(),
          domain: document.getElementById("domain-filter").value.toLowerCase(),
          purpose: document.getElementById("purpose-filter").value.toLowerCase(),
          resolvers: document.getElementById("resolvers-filter").value.toLowerCase(),
          arecords: document.getElementById("arecords-filter").value.toLowerCase(),
          ns: document.getElementById("ns-filter").value.toLowerCase(),
          mx: document.getElementById("mx-filter").value.toLowerCase(),
          ptr: document.getElementById("ptr-filter").value.toLowerCase(),
          dnsstatus: document.getElementById("dnsstatus-filter").value.toLowerCase(),
          cdnname: document.getElementById("cdnname-filter").value.toLowerCase(),
          cdntype: document.getElementById("cdntype-filter").value.toLowerCase(),
          port: document.getElementById("port-filter").value.toLowerCase(),
          url: document.getElementById("url-filter").value.toLowerCase(),
          screenshot: document.getElementById("screenshot-filter").value.toLowerCase(),
          location: document.getElementById("redirect-filter").value.toLowerCase(),
          title: document.getElementById("title-filter").value.toLowerCase(),
          webserver: document.getElementById("webserver-filter").value.toLowerCase(),
          login: document.getElementById("login-filter").value.toLowerCase(),
          apiEndpoint: document.getElementById("api-endpoint-filter").value.toLowerCase(),
          tech: document.getElementById("tech-filter").value.toLowerCase(),
          statuscode: document.getElementById("statuscode-filter").value.toLowerCase(),
          contentlength: document.getElementById("contentlength-filter").value.toLowerCase(),
          cdn: document.getElementById("cdn-filter").value.toLowerCase(),
          spf: document.getElementById("spf-filter").value.toLowerCase(),
          dkim: document.getElementById("dkim-filter").value.toLowerCase(),
          dmarc: document.getElementById("dmarc-filter").value.toLowerCase(),
          dnssec: document.getElementById("dnssec-filter").value.toLowerCase(),
          sslversion: document.getElementById("sslversion-filter").value.toLowerCase(),
          certexpiry: document.getElementById("certexpiry-filter").value.toLowerCase(),
          sslissuer: document.getElementById("sslissuer-filter").value.toLowerCase(),
          sts: document.getElementById("sts-filter").value.toLowerCase(),
          xfo: document.getElementById("xfo-filter").value.toLowerCase(),
          csp: document.getElementById("csp-filter").value.toLowerCase(),
          xss: document.getElementById("xss-filter").value.toLowerCase(),
          rp: document.getElementById("rp-filter").value.toLowerCase(),
          pp: document.getElementById("pp-filter").value.toLowerCase(),
          portsservices: document.getElementById("ports-services-filter").value.toLowerCase(),
          crawledlinks: document.getElementById("crawledlinks-filter").value.toLowerCase()

        };
        const filtered = allTableRows.filter(row => {
          const cells = Array.from(row.getElementsByTagName("td"));
          const cellTexts = cells.map(cell => getCellContentText(cell).toLowerCase());
          if (filters.priority && !(cellTexts[0] || "").includes(filters.priority)) return false;
          if (filters.domain && !(cellTexts[1] || "").includes(filters.domain)) return false;
          if (filters.purpose && !(cellTexts[2] || "").includes(filters.purpose)) return false;
          if (filters.resolvers && !(cellTexts[3] || "").includes(filters.resolvers)) return false;
          if (filters.arecords && !(cellTexts[4] || "").includes(filters.arecords)) return false;
          if (filters.ns && !(cellTexts[5] || "").includes(filters.ns)) return false;
          if (filters.mx && !(cellTexts[6] || "").includes(filters.mx)) return false;
          if (filters.ptr && !(cellTexts[7] || "").includes(filters.ptr)) return false;
          if (filters.dnsstatus && !(cellTexts[8] || "").includes(filters.dnsstatus)) return false;
          if (filters.cdnname && !(cellTexts[9] || "").includes(filters.cdnname)) return false;
          if (filters.cdntype && !(cellTexts[10] || "").includes(filters.cdntype)) return false;
          if (filters.port && !(cellTexts[11] || "").includes(filters.port)) return false;
          if (filters.url && !(cellTexts[12] || "").includes(filters.url)) return false;
          const screenshotFilter = filters.screenshot;
          if (screenshotFilter) {
            const screenshotCell = cells[13];
            const hasImage = !!(screenshotCell && screenshotCell.querySelector("img"));
            if (screenshotFilter === "has screenshot" && !hasImage) return false;
            if (screenshotFilter === "no screenshot" && hasImage) return false;
          }
          if (filters.location && !(cellTexts[14] || "").includes(filters.location)) return false;
          if (filters.title && !(cellTexts[15] || "").includes(filters.title)) return false;
          if (filters.webserver && !(cellTexts[16] || "").includes(filters.webserver)) return false;
          if (filters.login && !(cellTexts[17] || "").includes(filters.login)) return false;
          if (filters.apiEndpoint && !(cellTexts[18] || "").includes(filters.apiEndpoint)) return false;
          if (filters.tech && !(cellTexts[19] || "").includes(filters.tech)) return false;
          if (filters.statuscode && !(cellTexts[20] || "").includes(filters.statuscode)) return false;
          if (filters.contentlength && !(cellTexts[21] || "").includes(filters.contentlength)) return false;
          if (filters.cdn && !(cellTexts[22] || "").includes(filters.cdn)) return false;
          if (filters.spf && !(cellTexts[23] || "").includes(filters.spf)) return false;
          if (filters.dkim && !(cellTexts[24] || "").includes(filters.dkim)) return false;
          if (filters.dmarc && !(cellTexts[25] || "").includes(filters.dmarc)) return false;
          if (filters.dnssec && !(cellTexts[26] || "").includes(filters.dnssec)) return false;
          if (filters.sslversion && !(cellTexts[27] || "").includes(filters.sslversion)) return false;
          if (filters.certexpiry && !(cellTexts[28] || "").includes(filters.certexpiry)) return false;
          if (filters.sslissuer && !(cellTexts[29] || "").includes(filters.sslissuer)) return false;
          if (filters.sts && !(cellTexts[30] || "").includes(filters.sts)) return false;
          if (filters.xfo && !(cellTexts[31] || "").includes(filters.xfo)) return false;
          if (filters.csp && !(cellTexts[32] || "").includes(filters.csp)) return false;
          if (filters.xss && !(cellTexts[33] || "").includes(filters.xss)) return false;
          if (filters.rp && !(cellTexts[34] || "").includes(filters.rp)) return false;
          if (filters.pp && !(cellTexts[35] || "").includes(filters.pp)) return false;
          if (filters.portsservices && !(cellTexts[36] || "").includes(filters.portsservices)) return false;
          if (filters.crawledlinks && !(cellTexts[37] || "").includes(filters.crawledlinks)) return false;
          if (query) {
            const rowText = cellTexts.join(" ");
            if (!rowText.includes(query)) return false;
          }
          return true;
        });
        filtered.sort((a, b) => {
          const scoreA = parseInt(a.cells[0].innerText) || 0;
          const scoreB = parseInt(b.cells[0].innerText) || 0;
          return riskSortOrder === "asc" ? scoreA - scoreB : scoreB - scoreA;
        });
        return filtered;
      }

      function renderTable(filteredRows) {
        const tBody = document.getElementById("report-table-body");
        tBody.innerHTML = "";
        let startIndex = 0;
        let endIndex = filteredRows.length;
        if (rowsPerPage !== "all" && rowsPerPage !== Infinity) {
          startIndex = (currentPage - 1) * rowsPerPage;
          endIndex = startIndex + rowsPerPage;
        }
        const rowsToShow = filteredRows.slice(startIndex, endIndex);
        rowsToShow.forEach(row => {
          prepareRowCells(row);
          tBody.appendChild(row);
        });
        window.requestAnimationFrame(() => updateClampStates(rowsToShow));
        renderPaginationControls(filteredRows.length);
      }

      function renderPaginationControls(totalRows) {
        const paginationDiv = document.getElementById("paginationControls");
        paginationDiv.innerHTML = "";
        if (rowsPerPage === "all" || rowsPerPage === Infinity) return;
        const totalPages = Math.ceil(totalRows / rowsPerPage);
        const pageInfo = document.createElement("span");
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
        paginationDiv.appendChild(pageInfo);
        const prevBtn = document.createElement("button");
        prevBtn.textContent = "Prev";
        prevBtn.disabled = currentPage === 1;
        prevBtn.addEventListener("click", () => {
          if (currentPage > 1) {
            currentPage--;
            renderTable(getFilteredRows());
          }
        });
        paginationDiv.appendChild(prevBtn);
        const nextBtn = document.createElement("button");
        nextBtn.textContent = "Next";
        nextBtn.disabled = currentPage === totalPages;
        nextBtn.addEventListener("click", () => {
          if (currentPage < totalPages) {
            currentPage++;
            renderTable(getFilteredRows());
          }
        });
        paginationDiv.appendChild(nextBtn);
      }

      function onFilterChange() {
        currentPage = 1;
        renderTable(getFilteredRows());
      }

      function updateRowsPerPage() {
        const select = document.getElementById("rowsPerPageSelect");
        const value = select.value;
        rowsPerPage = value === "all" ? Infinity : parseInt(value, 10);
        currentPage = 1;
        renderTable(getFilteredRows());
      }

      function populateColumnFilters() {
        const uniqueCols = Array.from({ length: 38 }, () => new Set());
        allTableRows.forEach(row => {
          const cells = row.getElementsByTagName("td");
          for (let col = 0; col < 38; col++) {
            const cell = cells[col];
            if (!cell) continue;
            if (col === 13) {
              const hasImage = !!cell.querySelector("img");
              uniqueCols[col].add(hasImage ? "Has screenshot" : "No screenshot");
            } else {
              const text = getCellContentText(cell);
              if (text) uniqueCols[col].add(text);
            }
          }
        });
        function fillSelectOptions(selectId, values) {
          const select = document.getElementById(selectId);
          const existing = select.querySelectorAll("option:not([value=''])");
          existing.forEach(opt => opt.remove());
          if (selectId === "priority-filter") {
            values = values.filter(v => !isNaN(v)).sort((a, b) => b - a);
          } else {
            values.sort();
          }
          values.forEach(val => {
            if (val.toLowerCase() === "asc" || val.toLowerCase() === "desc") return;
            const option = document.createElement("option");
            option.value = val;
            option.textContent = val;
            select.appendChild(option);
          });
        }
        fillSelectOptions("priority-filter", [...uniqueCols[0]]);
        fillSelectOptions("domain-filter", [...uniqueCols[1]]);
        fillSelectOptions("purpose-filter", [...uniqueCols[2]]);
        fillSelectOptions("resolvers-filter", [...uniqueCols[3]]);
        fillSelectOptions("arecords-filter", [...uniqueCols[4]]);
        fillSelectOptions("ns-filter", [...uniqueCols[5]]);
        fillSelectOptions("mx-filter", [...uniqueCols[6]]);
        fillSelectOptions("ptr-filter", [...uniqueCols[7]]);
        fillSelectOptions("dnsstatus-filter", [...uniqueCols[8]]);
        fillSelectOptions("cdnname-filter", [...uniqueCols[9]]);
        fillSelectOptions("cdntype-filter", [...uniqueCols[10]]);
        fillSelectOptions("port-filter", [...uniqueCols[11]]);
        fillSelectOptions("url-filter", [...uniqueCols[12]]);
        fillSelectOptions("screenshot-filter", [...uniqueCols[13]]);
        fillSelectOptions("redirect-filter", [...uniqueCols[14]]);
        fillSelectOptions("title-filter", [...uniqueCols[15]]);
        fillSelectOptions("webserver-filter", [...uniqueCols[16]]);
        fillSelectOptions("login-filter", [...uniqueCols[17]]);
        fillSelectOptions("api-endpoint-filter", [...uniqueCols[18]]);
        fillSelectOptions("tech-filter", [...uniqueCols[19]]);
        fillSelectOptions("statuscode-filter", [...uniqueCols[20]]);
        fillSelectOptions("contentlength-filter", [...uniqueCols[21]]);
        fillSelectOptions("cdn-filter", [...uniqueCols[22]]);
        fillSelectOptions("spf-filter", [...uniqueCols[23]]);
        fillSelectOptions("dkim-filter", [...uniqueCols[24]]);
        fillSelectOptions("dmarc-filter", [...uniqueCols[25]]);
        fillSelectOptions("dnssec-filter", [...uniqueCols[26]]);
        fillSelectOptions("sslversion-filter", [...uniqueCols[27]]);
        fillSelectOptions("certexpiry-filter", [...uniqueCols[28]]);
        fillSelectOptions("sslissuer-filter", [...uniqueCols[29]]);
        fillSelectOptions("sts-filter", [...uniqueCols[30]]);
        fillSelectOptions("xfo-filter", [...uniqueCols[31]]);
        fillSelectOptions("csp-filter", [...uniqueCols[32]]);
        fillSelectOptions("xss-filter", [...uniqueCols[33]]);
        fillSelectOptions("rp-filter", [...uniqueCols[34]]);
        fillSelectOptions("pp-filter", [...uniqueCols[35]]);
        fillSelectOptions("ports-services-filter", [...uniqueCols[36]]);
        fillSelectOptions("crawledlinks-filter", [...uniqueCols[37]]);
      }

      document.getElementById("searchBox").addEventListener("input", onFilterChange);
      document.getElementById("rowsPerPageSelect").addEventListener("change", updateRowsPerPage);
      document.getElementById("riskSortToggle").addEventListener("click", function() {
        riskSortOrder = (riskSortOrder === "asc") ? "desc" : "asc";
        this.textContent = (riskSortOrder === "asc") ? "▲" : "▼";
        renderTable(getFilteredRows());
      });
      // Async data loading and report building
      async function loadData() {
        try {
